{
  "resolvedId": "C:/Users/.Freelancer/TICKET/node_modules/vite/dist/client/client.mjs",
  "transforms": [
    {
      "name": "__load__",
      "result": "import '@vite/env';\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    const firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.send(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.hmrClient.logger.debug(\n      `invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.send({ type: \"custom\", event, data });\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRClient {\n  constructor(logger, transport, importUpdatedModule) {\n    this.logger = logger;\n    this.transport = transport;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  send(payload) {\n    this.transport.send(payload).catch((err) => {\n      this.logger.error(err);\n    });\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (e.g. style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!(err instanceof Error) || !err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath, firstInvalidatedBy } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      try {\n        this.currentFirstInvalidatedBy = firstInvalidatedBy;\n        for (const { deps, fn } of qualifiedCallbacks) {\n          fn(\n            deps.map(\n              (dep) => dep === acceptedPath ? fetchedModule : void 0\n            )\n          );\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        this.logger.debug(`hot updated: ${loggedPath}`);\n      } finally {\n        this.currentFirstInvalidatedBy = void 0;\n      }\n    };\n  }\n}\n\n/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nlet nanoid = (size = 21) => {\n  let id = '';\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0];\n  }\n  return id\n};\n\ntypeof process !== \"undefined\" && process.platform === \"win32\";\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { promise, resolve, reject };\n}\n\nfunction reviveInvokeError(e) {\n  const error = new Error(e.message || \"Unknown invoke error\");\n  Object.assign(error, e, {\n    // pass the whole error instead of just the stacktrace\n    // so that it gets formatted nicely with console.log\n    runnerError: new Error(\"RunnerError\")\n  });\n  return error;\n}\nconst createInvokeableTransport = (transport) => {\n  if (transport.invoke) {\n    return {\n      ...transport,\n      async invoke(name, data) {\n        const result = await transport.invoke({\n          type: \"custom\",\n          event: \"vite:invoke\",\n          data: {\n            id: \"send\",\n            name,\n            data\n          }\n        });\n        if (\"error\" in result) {\n          throw reviveInvokeError(result.error);\n        }\n        return result.result;\n      }\n    };\n  }\n  if (!transport.send || !transport.connect) {\n    throw new Error(\n      \"transport must implement send and connect when invoke is not implemented\"\n    );\n  }\n  const rpcPromises = /* @__PURE__ */ new Map();\n  return {\n    ...transport,\n    connect({ onMessage, onDisconnection }) {\n      return transport.connect({\n        onMessage(payload) {\n          if (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n            const data = payload.data;\n            if (data.id.startsWith(\"response:\")) {\n              const invokeId = data.id.slice(\"response:\".length);\n              const promise = rpcPromises.get(invokeId);\n              if (!promise) return;\n              if (promise.timeoutId) clearTimeout(promise.timeoutId);\n              rpcPromises.delete(invokeId);\n              const { error, result } = data.data;\n              if (error) {\n                promise.reject(error);\n              } else {\n                promise.resolve(result);\n              }\n              return;\n            }\n          }\n          onMessage(payload);\n        },\n        onDisconnection\n      });\n    },\n    disconnect() {\n      rpcPromises.forEach((promise) => {\n        promise.reject(\n          new Error(\n            `transport was disconnected, cannot call ${JSON.stringify(promise.name)}`\n          )\n        );\n      });\n      rpcPromises.clear();\n      return transport.disconnect?.();\n    },\n    send(data) {\n      return transport.send(data);\n    },\n    async invoke(name, data) {\n      const promiseId = nanoid();\n      const wrappedData = {\n        type: \"custom\",\n        event: \"vite:invoke\",\n        data: {\n          name,\n          id: `send:${promiseId}`,\n          data\n        }\n      };\n      const sendPromise = transport.send(wrappedData);\n      const { promise, resolve, reject } = promiseWithResolvers();\n      const timeout = transport.timeout ?? 6e4;\n      let timeoutId;\n      if (timeout > 0) {\n        timeoutId = setTimeout(() => {\n          rpcPromises.delete(promiseId);\n          reject(\n            new Error(\n              `transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`\n            )\n          );\n        }, timeout);\n        timeoutId?.unref?.();\n      }\n      rpcPromises.set(promiseId, { resolve, reject, name, timeoutId });\n      if (sendPromise) {\n        sendPromise.catch((err) => {\n          clearTimeout(timeoutId);\n          rpcPromises.delete(promiseId);\n          reject(err);\n        });\n      }\n      try {\n        return await promise;\n      } catch (err) {\n        throw reviveInvokeError(err);\n      }\n    }\n  };\n};\nconst normalizeModuleRunnerTransport = (transport) => {\n  const invokeableTransport = createInvokeableTransport(transport);\n  let isConnected = !invokeableTransport.connect;\n  let connectingPromise;\n  return {\n    ...transport,\n    ...invokeableTransport.connect ? {\n      async connect(onMessage) {\n        if (isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n          return;\n        }\n        const maybePromise = invokeableTransport.connect({\n          onMessage: onMessage ?? (() => {\n          }),\n          onDisconnection() {\n            isConnected = false;\n          }\n        });\n        if (maybePromise) {\n          connectingPromise = maybePromise;\n          await connectingPromise;\n          connectingPromise = void 0;\n        }\n        isConnected = true;\n      }\n    } : {},\n    ...invokeableTransport.disconnect ? {\n      async disconnect() {\n        if (!isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n        }\n        isConnected = false;\n        await invokeableTransport.disconnect();\n      }\n    } : {},\n    async send(data) {\n      if (!invokeableTransport.send) return;\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"send was called before connect\");\n        }\n      }\n      await invokeableTransport.send(data);\n    },\n    async invoke(name, data) {\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"invoke was called before connect\");\n        }\n      }\n      return invokeableTransport.invoke(name, data);\n    }\n  };\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n  const pingInterval = options.pingInterval ?? 3e4;\n  let ws;\n  let pingIntervalId;\n  return {\n    async connect({ onMessage, onDisconnection }) {\n      const socket = options.createConnection();\n      socket.addEventListener(\"message\", async ({ data }) => {\n        onMessage(JSON.parse(data));\n      });\n      let isOpened = socket.readyState === socket.OPEN;\n      if (!isOpened) {\n        await new Promise((resolve, reject) => {\n          socket.addEventListener(\n            \"open\",\n            () => {\n              isOpened = true;\n              resolve();\n            },\n            { once: true }\n          );\n          socket.addEventListener(\"close\", async () => {\n            if (!isOpened) {\n              reject(new Error(\"WebSocket closed without opened.\"));\n              return;\n            }\n            onMessage({\n              type: \"custom\",\n              event: \"vite:ws:disconnect\",\n              data: { webSocket: socket }\n            });\n            onDisconnection();\n          });\n        });\n      }\n      onMessage({\n        type: \"custom\",\n        event: \"vite:ws:connect\",\n        data: { webSocket: socket }\n      });\n      ws = socket;\n      pingIntervalId = setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send(JSON.stringify({ type: \"ping\" }));\n        }\n      }, pingInterval);\n    },\n    disconnect() {\n      clearInterval(pingIntervalId);\n      ws?.close();\n    },\n    send(data) {\n      ws.send(JSON.stringify(data));\n    }\n  };\n};\n\nfunction createHMRHandler(handler) {\n  const queue = new Queue();\n  return (payload) => queue.enqueue(() => handler(payload));\n}\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.pending = false;\n  }\n  enqueue(promise) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        promise,\n        resolve,\n        reject\n      });\n      this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pending) {\n      return false;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n    this.pending = true;\n    item.promise().then(item.resolve).catch(item.reject).finally(() => {\n      this.pending = false;\n      this.dequeue();\n    });\n    return true;\n  }\n}\n\nconst hmrConfigName = __HMR_CONFIG_NAME__;\nconst base$1 = __BASE__ || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n    h(\"pre\", { class: \"file\", part: \"file\" }),\n    h(\"pre\", { class: \"frame\", part: \"frame\" }),\n    h(\"pre\", { class: \"stack\", part: \"stack\" }),\n    h(\n      \"div\",\n      { class: \"tip\", part: \"tip\" },\n      \"Click outside, press \",\n      h(\"kbd\", {}, \"Esc\"),\n      \" key, or fix the code to dismiss.\",\n      h(\"br\"),\n      \"You can also disable this overlay by setting \",\n      h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"),\n      \" to \",\n      h(\"code\", { part: \"config-option-value\" }, \"false\"),\n      \" in \",\n      h(\"code\", { part: \"config-file-name\" }, hmrConfigName),\n      \".\"\n    )\n  ),\n  h(\"style\", {}, templateStyle)\n);\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err, links = true) {\n    super();\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.appendChild(createTemplate());\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n    if (err.plugin) {\n      this.text(\".plugin\", `[plugin:${err.plugin}] `);\n    }\n    this.text(\".message-body\", message.trim());\n    const [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n    if (err.loc) {\n      this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n    } else if (err.id) {\n      this.text(\".file\", file);\n    }\n    if (hasFrame) {\n      this.text(\".frame\", err.frame.trim());\n    }\n    this.text(\".stack\", err.stack, links);\n    this.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener(\"click\", () => {\n      this.close();\n    });\n    this.closeOnEsc = (e) => {\n      if (e.key === \"Escape\" || e.code === \"Escape\") {\n        this.close();\n      }\n    };\n    document.addEventListener(\"keydown\", this.closeOnEsc);\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    } else {\n      let curIndex = 0;\n      let match;\n      fileRE.lastIndex = 0;\n      while (match = fileRE.exec(text)) {\n        const { 0: file, index } = match;\n        const frag = text.slice(curIndex, index);\n        el.appendChild(document.createTextNode(frag));\n        const link = document.createElement(\"a\");\n        link.textContent = file;\n        link.className = \"file-link\";\n        link.onclick = () => {\n          fetch(\n            new URL(\n              `${base$1}__open-in-editor?file=${encodeURIComponent(file)}`,\n              import.meta.url\n            )\n          );\n        };\n        el.appendChild(link);\n        curIndex += frag.length + file.length;\n      }\n    }\n  }\n  close() {\n    this.parentNode?.removeChild(this);\n    document.removeEventListener(\"keydown\", this.closeOnEsc);\n  }\n}\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || \"/\";\nconst hmrTimeout = __HMR_TIMEOUT__;\nconst wsToken = __WS_TOKEN__;\nconst transport = normalizeModuleRunnerTransport(\n  (() => {\n    let wsTransport = createWebSocketModuleRunnerTransport({\n      createConnection: () => new WebSocket(\n        `${socketProtocol}://${socketHost}?token=${wsToken}`,\n        \"vite-hmr\"\n      ),\n      pingInterval: hmrTimeout\n    });\n    return {\n      async connect(handlers) {\n        try {\n          await wsTransport.connect(handlers);\n        } catch (e) {\n          if (!hmrPort) {\n            wsTransport = createWebSocketModuleRunnerTransport({\n              createConnection: () => new WebSocket(\n                `${socketProtocol}://${directSocketHost}?token=${wsToken}`,\n                \"vite-hmr\"\n              ),\n              pingInterval: hmrTimeout\n            });\n            try {\n              await wsTransport.connect(handlers);\n              console.info(\n                \"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\"\n              );\n            } catch (e2) {\n              if (e2 instanceof Error && e2.message.includes(\"WebSocket closed without opened.\")) {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n                console.error(\n                  `[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`\n                );\n              }\n            }\n            return;\n          }\n          console.error(`[vite] failed to connect to websocket (${e}). `);\n          throw e;\n        }\n      },\n      async disconnect() {\n        await wsTransport.disconnect();\n      },\n      send(data) {\n        wsTransport.send(data);\n      }\n    };\n  })()\n);\nlet willUnload = false;\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"beforeunload\", () => {\n    willUnload = true;\n  });\n}\nfunction cleanUrl(pathname) {\n  const url = new URL(pathname, \"http://vite.dev\");\n  url.searchParams.delete(\"direct\");\n  return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n  let timer;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      location.reload();\n    }, time);\n  };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(\n  {\n    error: (err) => console.error(\"[vite]\", err),\n    debug: (...msg) => console.debug(\"[vite]\", ...msg)\n  },\n  transport,\n  async function importUpdatedModule({\n    acceptedPath,\n    timestamp,\n    explicitImportRequired,\n    isWithinCircularImport\n  }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n      /* @vite-ignore */\n      base + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`\n    );\n    if (isWithinCircularImport) {\n      importPromise.catch(() => {\n        console.info(\n          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`\n        );\n        pageReload();\n      });\n    }\n    return await importPromise;\n  }\n);\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n  switch (payload.type) {\n    case \"connected\":\n      console.debug(`[vite] connected.`);\n      break;\n    case \"update\":\n      await hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n      if (hasDocument) {\n        if (isFirstUpdate && hasErrorOverlay()) {\n          location.reload();\n          return;\n        } else {\n          if (enableOverlay) {\n            clearErrorOverlay();\n          }\n          isFirstUpdate = false;\n        }\n      }\n      await Promise.all(\n        payload.updates.map(async (update) => {\n          if (update.type === \"js-update\") {\n            return hmrClient.queueUpdate(update);\n          }\n          const { path, timestamp } = update;\n          const searchUrl = cleanUrl(path);\n          const el = Array.from(\n            document.querySelectorAll(\"link\")\n          ).find(\n            (e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl)\n          );\n          if (!el) {\n            return;\n          }\n          const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n          return new Promise((resolve) => {\n            const newLinkTag = el.cloneNode();\n            newLinkTag.href = new URL(newPath, el.href).href;\n            const removeOldEl = () => {\n              el.remove();\n              console.debug(`[vite] css hot updated: ${searchUrl}`);\n              resolve();\n            };\n            newLinkTag.addEventListener(\"load\", removeOldEl);\n            newLinkTag.addEventListener(\"error\", removeOldEl);\n            outdatedLinkTags.add(el);\n            el.after(newLinkTag);\n          });\n        })\n      );\n      await hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n      break;\n    case \"custom\": {\n      await hmrClient.notifyListeners(payload.event, payload.data);\n      if (payload.event === \"vite:ws:disconnect\") {\n        if (hasDocument && !willUnload) {\n          console.log(`[vite] server connection lost. Polling for restart...`);\n          const socket = payload.data.webSocket;\n          const url = new URL(socket.url);\n          url.search = \"\";\n          await waitForSuccessfulPing(url.href);\n          location.reload();\n        }\n      }\n      break;\n    }\n    case \"full-reload\":\n      await hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n      if (hasDocument) {\n        if (payload.path && payload.path.endsWith(\".html\")) {\n          const pagePath = decodeURI(location.pathname);\n          const payloadPath = base + payload.path.slice(1);\n          if (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) {\n            pageReload();\n          }\n          return;\n        } else {\n          pageReload();\n        }\n      }\n      break;\n    case \"prune\":\n      await hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n      await hmrClient.prunePaths(payload.paths);\n      break;\n    case \"error\": {\n      await hmrClient.notifyListeners(\"vite:error\", payload);\n      if (hasDocument) {\n        const err = payload.err;\n        if (enableOverlay) {\n          createErrorOverlay(err);\n        } else {\n          console.error(\n            `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n          );\n        }\n      }\n      break;\n    }\n    case \"ping\":\n      break;\n    default: {\n      const check = payload;\n      return check;\n    }\n  }\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n  clearErrorOverlay();\n  const { customElements } = globalThis;\n  if (customElements) {\n    const ErrorOverlayConstructor = customElements.get(overlayId);\n    document.body.appendChild(new ErrorOverlayConstructor(err));\n  }\n}\nfunction clearErrorOverlay() {\n  document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n  async function ping() {\n    const socket = new WebSocket(socketUrl, \"vite-ping\");\n    return new Promise((resolve) => {\n      function onOpen() {\n        resolve(true);\n        close();\n      }\n      function onError() {\n        resolve(false);\n        close();\n      }\n      function close() {\n        socket.removeEventListener(\"open\", onOpen);\n        socket.removeEventListener(\"error\", onError);\n        socket.close();\n      }\n      socket.addEventListener(\"open\", onOpen);\n      socket.addEventListener(\"error\", onError);\n    });\n  }\n  if (await ping()) {\n    return;\n  }\n  await wait(ms);\n  while (true) {\n    if (document.visibilityState === \"visible\") {\n      if (await ping()) {\n        break;\n      }\n      await wait(ms);\n    } else {\n      await waitForWindowShow();\n    }\n  }\n}\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n  return new Promise((resolve) => {\n    const onChange = async () => {\n      if (document.visibilityState === \"visible\") {\n        resolve();\n        document.removeEventListener(\"visibilitychange\", onChange);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onChange);\n  });\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) {\n  document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n    sheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n  });\n}\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    style = document.createElement(\"style\");\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-vite-dev-id\", id);\n    style.textContent = content;\n    if (cspNonce) {\n      style.setAttribute(\"nonce\", cspNonce);\n    }\n    if (!lastInsertedStyle) {\n      document.head.appendChild(style);\n      setTimeout(() => {\n        lastInsertedStyle = void 0;\n      }, 0);\n    } else {\n      lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n    }\n    lastInsertedStyle = style;\n  } else {\n    style.textContent = content;\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n    sheetsMap.delete(id);\n  }\n}\nfunction createHotContext(ownerPath) {\n  return new HMRContext(hmrClient, ownerPath);\n}\nfunction injectQuery(url, queryToInject) {\n  if (url[0] !== \".\" && url[0] !== \"/\") {\n    return url;\n  }\n  const pathname = url.replace(/[?#].*$/, \"\");\n  const { search, hash } = new URL(url, \"http://vite.dev\");\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n",
      "start": 1751856127292,
      "end": 1751856127292
    },
    {
      "name": "vite:react-babel",
      "start": 1751856127292,
      "end": 1751856127292,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1751856127293,
      "end": 1751856127293,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1751856127293,
      "end": 1751856127293,
      "order": "normal-normal"
    },
    {
      "name": "vite:define",
      "start": 1751856127293,
      "end": 1751856127293,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1751856127293,
      "end": 1751856127293,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "result": "import '@vite/env';\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    const firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.send(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.hmrClient.logger.debug(\n      `invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.send({ type: \"custom\", event, data });\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRClient {\n  constructor(logger, transport, importUpdatedModule) {\n    this.logger = logger;\n    this.transport = transport;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  send(payload) {\n    this.transport.send(payload).catch((err) => {\n      this.logger.error(err);\n    });\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (e.g. style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!(err instanceof Error) || !err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath, firstInvalidatedBy } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      try {\n        this.currentFirstInvalidatedBy = firstInvalidatedBy;\n        for (const { deps, fn } of qualifiedCallbacks) {\n          fn(\n            deps.map(\n              (dep) => dep === acceptedPath ? fetchedModule : void 0\n            )\n          );\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        this.logger.debug(`hot updated: ${loggedPath}`);\n      } finally {\n        this.currentFirstInvalidatedBy = void 0;\n      }\n    };\n  }\n}\n\n/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nlet nanoid = (size = 21) => {\n  let id = '';\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0];\n  }\n  return id\n};\n\ntypeof process !== \"undefined\" && process.platform === \"win32\";\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { promise, resolve, reject };\n}\n\nfunction reviveInvokeError(e) {\n  const error = new Error(e.message || \"Unknown invoke error\");\n  Object.assign(error, e, {\n    // pass the whole error instead of just the stacktrace\n    // so that it gets formatted nicely with console.log\n    runnerError: new Error(\"RunnerError\")\n  });\n  return error;\n}\nconst createInvokeableTransport = (transport) => {\n  if (transport.invoke) {\n    return {\n      ...transport,\n      async invoke(name, data) {\n        const result = await transport.invoke({\n          type: \"custom\",\n          event: \"vite:invoke\",\n          data: {\n            id: \"send\",\n            name,\n            data\n          }\n        });\n        if (\"error\" in result) {\n          throw reviveInvokeError(result.error);\n        }\n        return result.result;\n      }\n    };\n  }\n  if (!transport.send || !transport.connect) {\n    throw new Error(\n      \"transport must implement send and connect when invoke is not implemented\"\n    );\n  }\n  const rpcPromises = /* @__PURE__ */ new Map();\n  return {\n    ...transport,\n    connect({ onMessage, onDisconnection }) {\n      return transport.connect({\n        onMessage(payload) {\n          if (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n            const data = payload.data;\n            if (data.id.startsWith(\"response:\")) {\n              const invokeId = data.id.slice(\"response:\".length);\n              const promise = rpcPromises.get(invokeId);\n              if (!promise) return;\n              if (promise.timeoutId) clearTimeout(promise.timeoutId);\n              rpcPromises.delete(invokeId);\n              const { error, result } = data.data;\n              if (error) {\n                promise.reject(error);\n              } else {\n                promise.resolve(result);\n              }\n              return;\n            }\n          }\n          onMessage(payload);\n        },\n        onDisconnection\n      });\n    },\n    disconnect() {\n      rpcPromises.forEach((promise) => {\n        promise.reject(\n          new Error(\n            `transport was disconnected, cannot call ${JSON.stringify(promise.name)}`\n          )\n        );\n      });\n      rpcPromises.clear();\n      return transport.disconnect?.();\n    },\n    send(data) {\n      return transport.send(data);\n    },\n    async invoke(name, data) {\n      const promiseId = nanoid();\n      const wrappedData = {\n        type: \"custom\",\n        event: \"vite:invoke\",\n        data: {\n          name,\n          id: `send:${promiseId}`,\n          data\n        }\n      };\n      const sendPromise = transport.send(wrappedData);\n      const { promise, resolve, reject } = promiseWithResolvers();\n      const timeout = transport.timeout ?? 6e4;\n      let timeoutId;\n      if (timeout > 0) {\n        timeoutId = setTimeout(() => {\n          rpcPromises.delete(promiseId);\n          reject(\n            new Error(\n              `transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`\n            )\n          );\n        }, timeout);\n        timeoutId?.unref?.();\n      }\n      rpcPromises.set(promiseId, { resolve, reject, name, timeoutId });\n      if (sendPromise) {\n        sendPromise.catch((err) => {\n          clearTimeout(timeoutId);\n          rpcPromises.delete(promiseId);\n          reject(err);\n        });\n      }\n      try {\n        return await promise;\n      } catch (err) {\n        throw reviveInvokeError(err);\n      }\n    }\n  };\n};\nconst normalizeModuleRunnerTransport = (transport) => {\n  const invokeableTransport = createInvokeableTransport(transport);\n  let isConnected = !invokeableTransport.connect;\n  let connectingPromise;\n  return {\n    ...transport,\n    ...invokeableTransport.connect ? {\n      async connect(onMessage) {\n        if (isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n          return;\n        }\n        const maybePromise = invokeableTransport.connect({\n          onMessage: onMessage ?? (() => {\n          }),\n          onDisconnection() {\n            isConnected = false;\n          }\n        });\n        if (maybePromise) {\n          connectingPromise = maybePromise;\n          await connectingPromise;\n          connectingPromise = void 0;\n        }\n        isConnected = true;\n      }\n    } : {},\n    ...invokeableTransport.disconnect ? {\n      async disconnect() {\n        if (!isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n        }\n        isConnected = false;\n        await invokeableTransport.disconnect();\n      }\n    } : {},\n    async send(data) {\n      if (!invokeableTransport.send) return;\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"send was called before connect\");\n        }\n      }\n      await invokeableTransport.send(data);\n    },\n    async invoke(name, data) {\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"invoke was called before connect\");\n        }\n      }\n      return invokeableTransport.invoke(name, data);\n    }\n  };\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n  const pingInterval = options.pingInterval ?? 3e4;\n  let ws;\n  let pingIntervalId;\n  return {\n    async connect({ onMessage, onDisconnection }) {\n      const socket = options.createConnection();\n      socket.addEventListener(\"message\", async ({ data }) => {\n        onMessage(JSON.parse(data));\n      });\n      let isOpened = socket.readyState === socket.OPEN;\n      if (!isOpened) {\n        await new Promise((resolve, reject) => {\n          socket.addEventListener(\n            \"open\",\n            () => {\n              isOpened = true;\n              resolve();\n            },\n            { once: true }\n          );\n          socket.addEventListener(\"close\", async () => {\n            if (!isOpened) {\n              reject(new Error(\"WebSocket closed without opened.\"));\n              return;\n            }\n            onMessage({\n              type: \"custom\",\n              event: \"vite:ws:disconnect\",\n              data: { webSocket: socket }\n            });\n            onDisconnection();\n          });\n        });\n      }\n      onMessage({\n        type: \"custom\",\n        event: \"vite:ws:connect\",\n        data: { webSocket: socket }\n      });\n      ws = socket;\n      pingIntervalId = setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send(JSON.stringify({ type: \"ping\" }));\n        }\n      }, pingInterval);\n    },\n    disconnect() {\n      clearInterval(pingIntervalId);\n      ws?.close();\n    },\n    send(data) {\n      ws.send(JSON.stringify(data));\n    }\n  };\n};\n\nfunction createHMRHandler(handler) {\n  const queue = new Queue();\n  return (payload) => queue.enqueue(() => handler(payload));\n}\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.pending = false;\n  }\n  enqueue(promise) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        promise,\n        resolve,\n        reject\n      });\n      this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pending) {\n      return false;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n    this.pending = true;\n    item.promise().then(item.resolve).catch(item.reject).finally(() => {\n      this.pending = false;\n      this.dequeue();\n    });\n    return true;\n  }\n}\n\nconst hmrConfigName = __HMR_CONFIG_NAME__;\nconst base$1 = __BASE__ || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n    h(\"pre\", { class: \"file\", part: \"file\" }),\n    h(\"pre\", { class: \"frame\", part: \"frame\" }),\n    h(\"pre\", { class: \"stack\", part: \"stack\" }),\n    h(\n      \"div\",\n      { class: \"tip\", part: \"tip\" },\n      \"Click outside, press \",\n      h(\"kbd\", {}, \"Esc\"),\n      \" key, or fix the code to dismiss.\",\n      h(\"br\"),\n      \"You can also disable this overlay by setting \",\n      h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"),\n      \" to \",\n      h(\"code\", { part: \"config-option-value\" }, \"false\"),\n      \" in \",\n      h(\"code\", { part: \"config-file-name\" }, hmrConfigName),\n      \".\"\n    )\n  ),\n  h(\"style\", {}, templateStyle)\n);\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err, links = true) {\n    super();\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.appendChild(createTemplate());\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n    if (err.plugin) {\n      this.text(\".plugin\", `[plugin:${err.plugin}] `);\n    }\n    this.text(\".message-body\", message.trim());\n    const [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n    if (err.loc) {\n      this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n    } else if (err.id) {\n      this.text(\".file\", file);\n    }\n    if (hasFrame) {\n      this.text(\".frame\", err.frame.trim());\n    }\n    this.text(\".stack\", err.stack, links);\n    this.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener(\"click\", () => {\n      this.close();\n    });\n    this.closeOnEsc = (e) => {\n      if (e.key === \"Escape\" || e.code === \"Escape\") {\n        this.close();\n      }\n    };\n    document.addEventListener(\"keydown\", this.closeOnEsc);\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    } else {\n      let curIndex = 0;\n      let match;\n      fileRE.lastIndex = 0;\n      while (match = fileRE.exec(text)) {\n        const { 0: file, index } = match;\n        const frag = text.slice(curIndex, index);\n        el.appendChild(document.createTextNode(frag));\n        const link = document.createElement(\"a\");\n        link.textContent = file;\n        link.className = \"file-link\";\n        link.onclick = () => {\n          fetch(\n            new URL(\n              `${base$1}__open-in-editor?file=${encodeURIComponent(file)}`,\n              import.meta.url\n            )\n          );\n        };\n        el.appendChild(link);\n        curIndex += frag.length + file.length;\n      }\n    }\n  }\n  close() {\n    this.parentNode?.removeChild(this);\n    document.removeEventListener(\"keydown\", this.closeOnEsc);\n  }\n}\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || \"/\";\nconst hmrTimeout = __HMR_TIMEOUT__;\nconst wsToken = __WS_TOKEN__;\nconst transport = normalizeModuleRunnerTransport(\n  (() => {\n    let wsTransport = createWebSocketModuleRunnerTransport({\n      createConnection: () => new WebSocket(\n        `${socketProtocol}://${socketHost}?token=${wsToken}`,\n        \"vite-hmr\"\n      ),\n      pingInterval: hmrTimeout\n    });\n    return {\n      async connect(handlers) {\n        try {\n          await wsTransport.connect(handlers);\n        } catch (e) {\n          if (!hmrPort) {\n            wsTransport = createWebSocketModuleRunnerTransport({\n              createConnection: () => new WebSocket(\n                `${socketProtocol}://${directSocketHost}?token=${wsToken}`,\n                \"vite-hmr\"\n              ),\n              pingInterval: hmrTimeout\n            });\n            try {\n              await wsTransport.connect(handlers);\n              console.info(\n                \"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\"\n              );\n            } catch (e2) {\n              if (e2 instanceof Error && e2.message.includes(\"WebSocket closed without opened.\")) {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n                console.error(\n                  `[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`\n                );\n              }\n            }\n            return;\n          }\n          console.error(`[vite] failed to connect to websocket (${e}). `);\n          throw e;\n        }\n      },\n      async disconnect() {\n        await wsTransport.disconnect();\n      },\n      send(data) {\n        wsTransport.send(data);\n      }\n    };\n  })()\n);\nlet willUnload = false;\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"beforeunload\", () => {\n    willUnload = true;\n  });\n}\nfunction cleanUrl(pathname) {\n  const url = new URL(pathname, \"http://vite.dev\");\n  url.searchParams.delete(\"direct\");\n  return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n  let timer;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      location.reload();\n    }, time);\n  };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(\n  {\n    error: (err) => console.error(\"[vite]\", err),\n    debug: (...msg) => console.debug(\"[vite]\", ...msg)\n  },\n  transport,\n  async function importUpdatedModule({\n    acceptedPath,\n    timestamp,\n    explicitImportRequired,\n    isWithinCircularImport\n  }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n      /* @vite-ignore */\n      base + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`\n    );\n    if (isWithinCircularImport) {\n      importPromise.catch(() => {\n        console.info(\n          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`\n        );\n        pageReload();\n      });\n    }\n    return await importPromise;\n  }\n);\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n  switch (payload.type) {\n    case \"connected\":\n      console.debug(`[vite] connected.`);\n      break;\n    case \"update\":\n      await hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n      if (hasDocument) {\n        if (isFirstUpdate && hasErrorOverlay()) {\n          location.reload();\n          return;\n        } else {\n          if (enableOverlay) {\n            clearErrorOverlay();\n          }\n          isFirstUpdate = false;\n        }\n      }\n      await Promise.all(\n        payload.updates.map(async (update) => {\n          if (update.type === \"js-update\") {\n            return hmrClient.queueUpdate(update);\n          }\n          const { path, timestamp } = update;\n          const searchUrl = cleanUrl(path);\n          const el = Array.from(\n            document.querySelectorAll(\"link\")\n          ).find(\n            (e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl)\n          );\n          if (!el) {\n            return;\n          }\n          const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n          return new Promise((resolve) => {\n            const newLinkTag = el.cloneNode();\n            newLinkTag.href = new URL(newPath, el.href).href;\n            const removeOldEl = () => {\n              el.remove();\n              console.debug(`[vite] css hot updated: ${searchUrl}`);\n              resolve();\n            };\n            newLinkTag.addEventListener(\"load\", removeOldEl);\n            newLinkTag.addEventListener(\"error\", removeOldEl);\n            outdatedLinkTags.add(el);\n            el.after(newLinkTag);\n          });\n        })\n      );\n      await hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n      break;\n    case \"custom\": {\n      await hmrClient.notifyListeners(payload.event, payload.data);\n      if (payload.event === \"vite:ws:disconnect\") {\n        if (hasDocument && !willUnload) {\n          console.log(`[vite] server connection lost. Polling for restart...`);\n          const socket = payload.data.webSocket;\n          const url = new URL(socket.url);\n          url.search = \"\";\n          await waitForSuccessfulPing(url.href);\n          location.reload();\n        }\n      }\n      break;\n    }\n    case \"full-reload\":\n      await hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n      if (hasDocument) {\n        if (payload.path && payload.path.endsWith(\".html\")) {\n          const pagePath = decodeURI(location.pathname);\n          const payloadPath = base + payload.path.slice(1);\n          if (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) {\n            pageReload();\n          }\n          return;\n        } else {\n          pageReload();\n        }\n      }\n      break;\n    case \"prune\":\n      await hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n      await hmrClient.prunePaths(payload.paths);\n      break;\n    case \"error\": {\n      await hmrClient.notifyListeners(\"vite:error\", payload);\n      if (hasDocument) {\n        const err = payload.err;\n        if (enableOverlay) {\n          createErrorOverlay(err);\n        } else {\n          console.error(\n            `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n          );\n        }\n      }\n      break;\n    }\n    case \"ping\":\n      break;\n    default: {\n      const check = payload;\n      return check;\n    }\n  }\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n  clearErrorOverlay();\n  const { customElements } = globalThis;\n  if (customElements) {\n    const ErrorOverlayConstructor = customElements.get(overlayId);\n    document.body.appendChild(new ErrorOverlayConstructor(err));\n  }\n}\nfunction clearErrorOverlay() {\n  document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n  async function ping() {\n    const socket = new WebSocket(socketUrl, \"vite-ping\");\n    return new Promise((resolve) => {\n      function onOpen() {\n        resolve(true);\n        close();\n      }\n      function onError() {\n        resolve(false);\n        close();\n      }\n      function close() {\n        socket.removeEventListener(\"open\", onOpen);\n        socket.removeEventListener(\"error\", onError);\n        socket.close();\n      }\n      socket.addEventListener(\"open\", onOpen);\n      socket.addEventListener(\"error\", onError);\n    });\n  }\n  if (await ping()) {\n    return;\n  }\n  await wait(ms);\n  while (true) {\n    if (document.visibilityState === \"visible\") {\n      if (await ping()) {\n        break;\n      }\n      await wait(ms);\n    } else {\n      await waitForWindowShow();\n    }\n  }\n}\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n  return new Promise((resolve) => {\n    const onChange = async () => {\n      if (document.visibilityState === \"visible\") {\n        resolve();\n        document.removeEventListener(\"visibilitychange\", onChange);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onChange);\n  });\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) {\n  document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n    sheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n  });\n}\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    style = document.createElement(\"style\");\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-vite-dev-id\", id);\n    style.textContent = content;\n    if (cspNonce) {\n      style.setAttribute(\"nonce\", cspNonce);\n    }\n    if (!lastInsertedStyle) {\n      document.head.appendChild(style);\n      setTimeout(() => {\n        lastInsertedStyle = void 0;\n      }, 0);\n    } else {\n      lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n    }\n    lastInsertedStyle = style;\n  } else {\n    style.textContent = content;\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n    sheetsMap.delete(id);\n  }\n}\nfunction createHotContext(ownerPath) {\n  return new HMRContext(hmrClient, ownerPath);\n}\nfunction injectQuery(url, queryToInject) {\n  if (url[0] !== \".\" && url[0] !== \"/\") {\n    return url;\n  }\n  const pathname = url.replace(/[?#].*$/, \"\");\n  const { search, hash } = new URL(url, \"http://vite.dev\");\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n",
      "start": 1751856127293,
      "end": 1751856127311,
      "order": "normal-normal",
      "sourcemaps": null
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1751856127312,
      "end": 1751856127312,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1751856127312,
      "end": 1751856127312,
      "order": "normal-normal"
    },
    {
      "name": "vite:client-inject",
      "result": "import '@vite/env';\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    const firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.send(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.hmrClient.logger.debug(\n      `invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.send({ type: \"custom\", event, data });\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRClient {\n  constructor(logger, transport, importUpdatedModule) {\n    this.logger = logger;\n    this.transport = transport;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  send(payload) {\n    this.transport.send(payload).catch((err) => {\n      this.logger.error(err);\n    });\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (e.g. style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!(err instanceof Error) || !err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath, firstInvalidatedBy } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      try {\n        this.currentFirstInvalidatedBy = firstInvalidatedBy;\n        for (const { deps, fn } of qualifiedCallbacks) {\n          fn(\n            deps.map(\n              (dep) => dep === acceptedPath ? fetchedModule : void 0\n            )\n          );\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        this.logger.debug(`hot updated: ${loggedPath}`);\n      } finally {\n        this.currentFirstInvalidatedBy = void 0;\n      }\n    };\n  }\n}\n\n/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nlet nanoid = (size = 21) => {\n  let id = '';\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0];\n  }\n  return id\n};\n\ntypeof process !== \"undefined\" && process.platform === \"win32\";\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { promise, resolve, reject };\n}\n\nfunction reviveInvokeError(e) {\n  const error = new Error(e.message || \"Unknown invoke error\");\n  Object.assign(error, e, {\n    // pass the whole error instead of just the stacktrace\n    // so that it gets formatted nicely with console.log\n    runnerError: new Error(\"RunnerError\")\n  });\n  return error;\n}\nconst createInvokeableTransport = (transport) => {\n  if (transport.invoke) {\n    return {\n      ...transport,\n      async invoke(name, data) {\n        const result = await transport.invoke({\n          type: \"custom\",\n          event: \"vite:invoke\",\n          data: {\n            id: \"send\",\n            name,\n            data\n          }\n        });\n        if (\"error\" in result) {\n          throw reviveInvokeError(result.error);\n        }\n        return result.result;\n      }\n    };\n  }\n  if (!transport.send || !transport.connect) {\n    throw new Error(\n      \"transport must implement send and connect when invoke is not implemented\"\n    );\n  }\n  const rpcPromises = /* @__PURE__ */ new Map();\n  return {\n    ...transport,\n    connect({ onMessage, onDisconnection }) {\n      return transport.connect({\n        onMessage(payload) {\n          if (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n            const data = payload.data;\n            if (data.id.startsWith(\"response:\")) {\n              const invokeId = data.id.slice(\"response:\".length);\n              const promise = rpcPromises.get(invokeId);\n              if (!promise) return;\n              if (promise.timeoutId) clearTimeout(promise.timeoutId);\n              rpcPromises.delete(invokeId);\n              const { error, result } = data.data;\n              if (error) {\n                promise.reject(error);\n              } else {\n                promise.resolve(result);\n              }\n              return;\n            }\n          }\n          onMessage(payload);\n        },\n        onDisconnection\n      });\n    },\n    disconnect() {\n      rpcPromises.forEach((promise) => {\n        promise.reject(\n          new Error(\n            `transport was disconnected, cannot call ${JSON.stringify(promise.name)}`\n          )\n        );\n      });\n      rpcPromises.clear();\n      return transport.disconnect?.();\n    },\n    send(data) {\n      return transport.send(data);\n    },\n    async invoke(name, data) {\n      const promiseId = nanoid();\n      const wrappedData = {\n        type: \"custom\",\n        event: \"vite:invoke\",\n        data: {\n          name,\n          id: `send:${promiseId}`,\n          data\n        }\n      };\n      const sendPromise = transport.send(wrappedData);\n      const { promise, resolve, reject } = promiseWithResolvers();\n      const timeout = transport.timeout ?? 6e4;\n      let timeoutId;\n      if (timeout > 0) {\n        timeoutId = setTimeout(() => {\n          rpcPromises.delete(promiseId);\n          reject(\n            new Error(\n              `transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`\n            )\n          );\n        }, timeout);\n        timeoutId?.unref?.();\n      }\n      rpcPromises.set(promiseId, { resolve, reject, name, timeoutId });\n      if (sendPromise) {\n        sendPromise.catch((err) => {\n          clearTimeout(timeoutId);\n          rpcPromises.delete(promiseId);\n          reject(err);\n        });\n      }\n      try {\n        return await promise;\n      } catch (err) {\n        throw reviveInvokeError(err);\n      }\n    }\n  };\n};\nconst normalizeModuleRunnerTransport = (transport) => {\n  const invokeableTransport = createInvokeableTransport(transport);\n  let isConnected = !invokeableTransport.connect;\n  let connectingPromise;\n  return {\n    ...transport,\n    ...invokeableTransport.connect ? {\n      async connect(onMessage) {\n        if (isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n          return;\n        }\n        const maybePromise = invokeableTransport.connect({\n          onMessage: onMessage ?? (() => {\n          }),\n          onDisconnection() {\n            isConnected = false;\n          }\n        });\n        if (maybePromise) {\n          connectingPromise = maybePromise;\n          await connectingPromise;\n          connectingPromise = void 0;\n        }\n        isConnected = true;\n      }\n    } : {},\n    ...invokeableTransport.disconnect ? {\n      async disconnect() {\n        if (!isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n        }\n        isConnected = false;\n        await invokeableTransport.disconnect();\n      }\n    } : {},\n    async send(data) {\n      if (!invokeableTransport.send) return;\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"send was called before connect\");\n        }\n      }\n      await invokeableTransport.send(data);\n    },\n    async invoke(name, data) {\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"invoke was called before connect\");\n        }\n      }\n      return invokeableTransport.invoke(name, data);\n    }\n  };\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n  const pingInterval = options.pingInterval ?? 3e4;\n  let ws;\n  let pingIntervalId;\n  return {\n    async connect({ onMessage, onDisconnection }) {\n      const socket = options.createConnection();\n      socket.addEventListener(\"message\", async ({ data }) => {\n        onMessage(JSON.parse(data));\n      });\n      let isOpened = socket.readyState === socket.OPEN;\n      if (!isOpened) {\n        await new Promise((resolve, reject) => {\n          socket.addEventListener(\n            \"open\",\n            () => {\n              isOpened = true;\n              resolve();\n            },\n            { once: true }\n          );\n          socket.addEventListener(\"close\", async () => {\n            if (!isOpened) {\n              reject(new Error(\"WebSocket closed without opened.\"));\n              return;\n            }\n            onMessage({\n              type: \"custom\",\n              event: \"vite:ws:disconnect\",\n              data: { webSocket: socket }\n            });\n            onDisconnection();\n          });\n        });\n      }\n      onMessage({\n        type: \"custom\",\n        event: \"vite:ws:connect\",\n        data: { webSocket: socket }\n      });\n      ws = socket;\n      pingIntervalId = setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send(JSON.stringify({ type: \"ping\" }));\n        }\n      }, pingInterval);\n    },\n    disconnect() {\n      clearInterval(pingIntervalId);\n      ws?.close();\n    },\n    send(data) {\n      ws.send(JSON.stringify(data));\n    }\n  };\n};\n\nfunction createHMRHandler(handler) {\n  const queue = new Queue();\n  return (payload) => queue.enqueue(() => handler(payload));\n}\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.pending = false;\n  }\n  enqueue(promise) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        promise,\n        resolve,\n        reject\n      });\n      this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pending) {\n      return false;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n    this.pending = true;\n    item.promise().then(item.resolve).catch(item.reject).finally(() => {\n      this.pending = false;\n      this.dequeue();\n    });\n    return true;\n  }\n}\n\nconst hmrConfigName = \"vite.config.js\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n    h(\"pre\", { class: \"file\", part: \"file\" }),\n    h(\"pre\", { class: \"frame\", part: \"frame\" }),\n    h(\"pre\", { class: \"stack\", part: \"stack\" }),\n    h(\n      \"div\",\n      { class: \"tip\", part: \"tip\" },\n      \"Click outside, press \",\n      h(\"kbd\", {}, \"Esc\"),\n      \" key, or fix the code to dismiss.\",\n      h(\"br\"),\n      \"You can also disable this overlay by setting \",\n      h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"),\n      \" to \",\n      h(\"code\", { part: \"config-option-value\" }, \"false\"),\n      \" in \",\n      h(\"code\", { part: \"config-file-name\" }, hmrConfigName),\n      \".\"\n    )\n  ),\n  h(\"style\", {}, templateStyle)\n);\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err, links = true) {\n    super();\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.appendChild(createTemplate());\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n    if (err.plugin) {\n      this.text(\".plugin\", `[plugin:${err.plugin}] `);\n    }\n    this.text(\".message-body\", message.trim());\n    const [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n    if (err.loc) {\n      this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n    } else if (err.id) {\n      this.text(\".file\", file);\n    }\n    if (hasFrame) {\n      this.text(\".frame\", err.frame.trim());\n    }\n    this.text(\".stack\", err.stack, links);\n    this.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener(\"click\", () => {\n      this.close();\n    });\n    this.closeOnEsc = (e) => {\n      if (e.key === \"Escape\" || e.code === \"Escape\") {\n        this.close();\n      }\n    };\n    document.addEventListener(\"keydown\", this.closeOnEsc);\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    } else {\n      let curIndex = 0;\n      let match;\n      fileRE.lastIndex = 0;\n      while (match = fileRE.exec(text)) {\n        const { 0: file, index } = match;\n        const frag = text.slice(curIndex, index);\n        el.appendChild(document.createTextNode(frag));\n        const link = document.createElement(\"a\");\n        link.textContent = file;\n        link.className = \"file-link\";\n        link.onclick = () => {\n          fetch(\n            new URL(\n              `${base$1}__open-in-editor?file=${encodeURIComponent(file)}`,\n              import.meta.url\n            )\n          );\n        };\n        el.appendChild(link);\n        curIndex += frag.length + file.length;\n      }\n    }\n  }\n  close() {\n    this.parentNode?.removeChild(this);\n    document.removeEventListener(\"keydown\", this.closeOnEsc);\n  }\n}\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || \"/\";\nconst hmrTimeout = 30000;\nconst wsToken = \"FiU-Pqyvfk9u\";\nconst transport = normalizeModuleRunnerTransport(\n  (() => {\n    let wsTransport = createWebSocketModuleRunnerTransport({\n      createConnection: () => new WebSocket(\n        `${socketProtocol}://${socketHost}?token=${wsToken}`,\n        \"vite-hmr\"\n      ),\n      pingInterval: hmrTimeout\n    });\n    return {\n      async connect(handlers) {\n        try {\n          await wsTransport.connect(handlers);\n        } catch (e) {\n          if (!hmrPort) {\n            wsTransport = createWebSocketModuleRunnerTransport({\n              createConnection: () => new WebSocket(\n                `${socketProtocol}://${directSocketHost}?token=${wsToken}`,\n                \"vite-hmr\"\n              ),\n              pingInterval: hmrTimeout\n            });\n            try {\n              await wsTransport.connect(handlers);\n              console.info(\n                \"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\"\n              );\n            } catch (e2) {\n              if (e2 instanceof Error && e2.message.includes(\"WebSocket closed without opened.\")) {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n                console.error(\n                  `[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`\n                );\n              }\n            }\n            return;\n          }\n          console.error(`[vite] failed to connect to websocket (${e}). `);\n          throw e;\n        }\n      },\n      async disconnect() {\n        await wsTransport.disconnect();\n      },\n      send(data) {\n        wsTransport.send(data);\n      }\n    };\n  })()\n);\nlet willUnload = false;\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"beforeunload\", () => {\n    willUnload = true;\n  });\n}\nfunction cleanUrl(pathname) {\n  const url = new URL(pathname, \"http://vite.dev\");\n  url.searchParams.delete(\"direct\");\n  return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n  let timer;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      location.reload();\n    }, time);\n  };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(\n  {\n    error: (err) => console.error(\"[vite]\", err),\n    debug: (...msg) => console.debug(\"[vite]\", ...msg)\n  },\n  transport,\n  async function importUpdatedModule({\n    acceptedPath,\n    timestamp,\n    explicitImportRequired,\n    isWithinCircularImport\n  }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n      /* @vite-ignore */\n      base + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`\n    );\n    if (isWithinCircularImport) {\n      importPromise.catch(() => {\n        console.info(\n          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`\n        );\n        pageReload();\n      });\n    }\n    return await importPromise;\n  }\n);\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n  switch (payload.type) {\n    case \"connected\":\n      console.debug(`[vite] connected.`);\n      break;\n    case \"update\":\n      await hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n      if (hasDocument) {\n        if (isFirstUpdate && hasErrorOverlay()) {\n          location.reload();\n          return;\n        } else {\n          if (enableOverlay) {\n            clearErrorOverlay();\n          }\n          isFirstUpdate = false;\n        }\n      }\n      await Promise.all(\n        payload.updates.map(async (update) => {\n          if (update.type === \"js-update\") {\n            return hmrClient.queueUpdate(update);\n          }\n          const { path, timestamp } = update;\n          const searchUrl = cleanUrl(path);\n          const el = Array.from(\n            document.querySelectorAll(\"link\")\n          ).find(\n            (e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl)\n          );\n          if (!el) {\n            return;\n          }\n          const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n          return new Promise((resolve) => {\n            const newLinkTag = el.cloneNode();\n            newLinkTag.href = new URL(newPath, el.href).href;\n            const removeOldEl = () => {\n              el.remove();\n              console.debug(`[vite] css hot updated: ${searchUrl}`);\n              resolve();\n            };\n            newLinkTag.addEventListener(\"load\", removeOldEl);\n            newLinkTag.addEventListener(\"error\", removeOldEl);\n            outdatedLinkTags.add(el);\n            el.after(newLinkTag);\n          });\n        })\n      );\n      await hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n      break;\n    case \"custom\": {\n      await hmrClient.notifyListeners(payload.event, payload.data);\n      if (payload.event === \"vite:ws:disconnect\") {\n        if (hasDocument && !willUnload) {\n          console.log(`[vite] server connection lost. Polling for restart...`);\n          const socket = payload.data.webSocket;\n          const url = new URL(socket.url);\n          url.search = \"\";\n          await waitForSuccessfulPing(url.href);\n          location.reload();\n        }\n      }\n      break;\n    }\n    case \"full-reload\":\n      await hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n      if (hasDocument) {\n        if (payload.path && payload.path.endsWith(\".html\")) {\n          const pagePath = decodeURI(location.pathname);\n          const payloadPath = base + payload.path.slice(1);\n          if (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) {\n            pageReload();\n          }\n          return;\n        } else {\n          pageReload();\n        }\n      }\n      break;\n    case \"prune\":\n      await hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n      await hmrClient.prunePaths(payload.paths);\n      break;\n    case \"error\": {\n      await hmrClient.notifyListeners(\"vite:error\", payload);\n      if (hasDocument) {\n        const err = payload.err;\n        if (enableOverlay) {\n          createErrorOverlay(err);\n        } else {\n          console.error(\n            `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n          );\n        }\n      }\n      break;\n    }\n    case \"ping\":\n      break;\n    default: {\n      const check = payload;\n      return check;\n    }\n  }\n}\nconst enableOverlay = true;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n  clearErrorOverlay();\n  const { customElements } = globalThis;\n  if (customElements) {\n    const ErrorOverlayConstructor = customElements.get(overlayId);\n    document.body.appendChild(new ErrorOverlayConstructor(err));\n  }\n}\nfunction clearErrorOverlay() {\n  document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n  async function ping() {\n    const socket = new WebSocket(socketUrl, \"vite-ping\");\n    return new Promise((resolve) => {\n      function onOpen() {\n        resolve(true);\n        close();\n      }\n      function onError() {\n        resolve(false);\n        close();\n      }\n      function close() {\n        socket.removeEventListener(\"open\", onOpen);\n        socket.removeEventListener(\"error\", onError);\n        socket.close();\n      }\n      socket.addEventListener(\"open\", onOpen);\n      socket.addEventListener(\"error\", onError);\n    });\n  }\n  if (await ping()) {\n    return;\n  }\n  await wait(ms);\n  while (true) {\n    if (document.visibilityState === \"visible\") {\n      if (await ping()) {\n        break;\n      }\n      await wait(ms);\n    } else {\n      await waitForWindowShow();\n    }\n  }\n}\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n  return new Promise((resolve) => {\n    const onChange = async () => {\n      if (document.visibilityState === \"visible\") {\n        resolve();\n        document.removeEventListener(\"visibilitychange\", onChange);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onChange);\n  });\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) {\n  document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n    sheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n  });\n}\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    style = document.createElement(\"style\");\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-vite-dev-id\", id);\n    style.textContent = content;\n    if (cspNonce) {\n      style.setAttribute(\"nonce\", cspNonce);\n    }\n    if (!lastInsertedStyle) {\n      document.head.appendChild(style);\n      setTimeout(() => {\n        lastInsertedStyle = void 0;\n      }, 0);\n    } else {\n      lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n    }\n    lastInsertedStyle = style;\n  } else {\n    style.textContent = content;\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n    sheetsMap.delete(id);\n  }\n}\nfunction createHotContext(ownerPath) {\n  return new HMRContext(hmrClient, ownerPath);\n}\nfunction injectQuery(url, queryToInject) {\n  if (url[0] !== \".\" && url[0] !== \"/\") {\n    return url;\n  }\n  const pathname = url.replace(/[?#].*$/, \"\");\n  const { search, hash } = new URL(url, \"http://vite.dev\");\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n",
      "start": 1751856127312,
      "end": 1751856127313,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-analysis",
      "start": 1751856127313,
      "end": 1751856127313,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import \"/node_modules/vite/dist/client/env.mjs\";\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    const firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.send(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message,\n      firstInvalidatedBy\n    });\n    this.hmrClient.logger.debug(\n      `invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.send({ type: \"custom\", event, data });\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRClient {\n  constructor(logger, transport, importUpdatedModule) {\n    this.logger = logger;\n    this.transport = transport;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  send(payload) {\n    this.transport.send(payload).catch((err) => {\n      this.logger.error(err);\n    });\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (e.g. style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!(err instanceof Error) || !err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath, firstInvalidatedBy } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      try {\n        this.currentFirstInvalidatedBy = firstInvalidatedBy;\n        for (const { deps, fn } of qualifiedCallbacks) {\n          fn(\n            deps.map(\n              (dep) => dep === acceptedPath ? fetchedModule : void 0\n            )\n          );\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        this.logger.debug(`hot updated: ${loggedPath}`);\n      } finally {\n        this.currentFirstInvalidatedBy = void 0;\n      }\n    };\n  }\n}\n\n/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nlet nanoid = (size = 21) => {\n  let id = '';\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0];\n  }\n  return id\n};\n\ntypeof process !== \"undefined\" && process.platform === \"win32\";\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { promise, resolve, reject };\n}\n\nfunction reviveInvokeError(e) {\n  const error = new Error(e.message || \"Unknown invoke error\");\n  Object.assign(error, e, {\n    // pass the whole error instead of just the stacktrace\n    // so that it gets formatted nicely with console.log\n    runnerError: new Error(\"RunnerError\")\n  });\n  return error;\n}\nconst createInvokeableTransport = (transport) => {\n  if (transport.invoke) {\n    return {\n      ...transport,\n      async invoke(name, data) {\n        const result = await transport.invoke({\n          type: \"custom\",\n          event: \"vite:invoke\",\n          data: {\n            id: \"send\",\n            name,\n            data\n          }\n        });\n        if (\"error\" in result) {\n          throw reviveInvokeError(result.error);\n        }\n        return result.result;\n      }\n    };\n  }\n  if (!transport.send || !transport.connect) {\n    throw new Error(\n      \"transport must implement send and connect when invoke is not implemented\"\n    );\n  }\n  const rpcPromises = /* @__PURE__ */ new Map();\n  return {\n    ...transport,\n    connect({ onMessage, onDisconnection }) {\n      return transport.connect({\n        onMessage(payload) {\n          if (payload.type === \"custom\" && payload.event === \"vite:invoke\") {\n            const data = payload.data;\n            if (data.id.startsWith(\"response:\")) {\n              const invokeId = data.id.slice(\"response:\".length);\n              const promise = rpcPromises.get(invokeId);\n              if (!promise) return;\n              if (promise.timeoutId) clearTimeout(promise.timeoutId);\n              rpcPromises.delete(invokeId);\n              const { error, result } = data.data;\n              if (error) {\n                promise.reject(error);\n              } else {\n                promise.resolve(result);\n              }\n              return;\n            }\n          }\n          onMessage(payload);\n        },\n        onDisconnection\n      });\n    },\n    disconnect() {\n      rpcPromises.forEach((promise) => {\n        promise.reject(\n          new Error(\n            `transport was disconnected, cannot call ${JSON.stringify(promise.name)}`\n          )\n        );\n      });\n      rpcPromises.clear();\n      return transport.disconnect?.();\n    },\n    send(data) {\n      return transport.send(data);\n    },\n    async invoke(name, data) {\n      const promiseId = nanoid();\n      const wrappedData = {\n        type: \"custom\",\n        event: \"vite:invoke\",\n        data: {\n          name,\n          id: `send:${promiseId}`,\n          data\n        }\n      };\n      const sendPromise = transport.send(wrappedData);\n      const { promise, resolve, reject } = promiseWithResolvers();\n      const timeout = transport.timeout ?? 6e4;\n      let timeoutId;\n      if (timeout > 0) {\n        timeoutId = setTimeout(() => {\n          rpcPromises.delete(promiseId);\n          reject(\n            new Error(\n              `transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`\n            )\n          );\n        }, timeout);\n        timeoutId?.unref?.();\n      }\n      rpcPromises.set(promiseId, { resolve, reject, name, timeoutId });\n      if (sendPromise) {\n        sendPromise.catch((err) => {\n          clearTimeout(timeoutId);\n          rpcPromises.delete(promiseId);\n          reject(err);\n        });\n      }\n      try {\n        return await promise;\n      } catch (err) {\n        throw reviveInvokeError(err);\n      }\n    }\n  };\n};\nconst normalizeModuleRunnerTransport = (transport) => {\n  const invokeableTransport = createInvokeableTransport(transport);\n  let isConnected = !invokeableTransport.connect;\n  let connectingPromise;\n  return {\n    ...transport,\n    ...invokeableTransport.connect ? {\n      async connect(onMessage) {\n        if (isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n          return;\n        }\n        const maybePromise = invokeableTransport.connect({\n          onMessage: onMessage ?? (() => {\n          }),\n          onDisconnection() {\n            isConnected = false;\n          }\n        });\n        if (maybePromise) {\n          connectingPromise = maybePromise;\n          await connectingPromise;\n          connectingPromise = void 0;\n        }\n        isConnected = true;\n      }\n    } : {},\n    ...invokeableTransport.disconnect ? {\n      async disconnect() {\n        if (!isConnected) return;\n        if (connectingPromise) {\n          await connectingPromise;\n        }\n        isConnected = false;\n        await invokeableTransport.disconnect();\n      }\n    } : {},\n    async send(data) {\n      if (!invokeableTransport.send) return;\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"send was called before connect\");\n        }\n      }\n      await invokeableTransport.send(data);\n    },\n    async invoke(name, data) {\n      if (!isConnected) {\n        if (connectingPromise) {\n          await connectingPromise;\n        } else {\n          throw new Error(\"invoke was called before connect\");\n        }\n      }\n      return invokeableTransport.invoke(name, data);\n    }\n  };\n};\nconst createWebSocketModuleRunnerTransport = (options) => {\n  const pingInterval = options.pingInterval ?? 3e4;\n  let ws;\n  let pingIntervalId;\n  return {\n    async connect({ onMessage, onDisconnection }) {\n      const socket = options.createConnection();\n      socket.addEventListener(\"message\", async ({ data }) => {\n        onMessage(JSON.parse(data));\n      });\n      let isOpened = socket.readyState === socket.OPEN;\n      if (!isOpened) {\n        await new Promise((resolve, reject) => {\n          socket.addEventListener(\n            \"open\",\n            () => {\n              isOpened = true;\n              resolve();\n            },\n            { once: true }\n          );\n          socket.addEventListener(\"close\", async () => {\n            if (!isOpened) {\n              reject(new Error(\"WebSocket closed without opened.\"));\n              return;\n            }\n            onMessage({\n              type: \"custom\",\n              event: \"vite:ws:disconnect\",\n              data: { webSocket: socket }\n            });\n            onDisconnection();\n          });\n        });\n      }\n      onMessage({\n        type: \"custom\",\n        event: \"vite:ws:connect\",\n        data: { webSocket: socket }\n      });\n      ws = socket;\n      pingIntervalId = setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send(JSON.stringify({ type: \"ping\" }));\n        }\n      }, pingInterval);\n    },\n    disconnect() {\n      clearInterval(pingIntervalId);\n      ws?.close();\n    },\n    send(data) {\n      ws.send(JSON.stringify(data));\n    }\n  };\n};\n\nfunction createHMRHandler(handler) {\n  const queue = new Queue();\n  return (payload) => queue.enqueue(() => handler(payload));\n}\nclass Queue {\n  constructor() {\n    this.queue = [];\n    this.pending = false;\n  }\n  enqueue(promise) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        promise,\n        resolve,\n        reject\n      });\n      this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pending) {\n      return false;\n    }\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n    this.pending = true;\n    item.promise().then(item.resolve).catch(item.reject).finally(() => {\n      this.pending = false;\n      this.dequeue();\n    });\n    return true;\n  }\n}\n\nconst hmrConfigName = \"vite.config.js\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n    h(\"pre\", { class: \"file\", part: \"file\" }),\n    h(\"pre\", { class: \"frame\", part: \"frame\" }),\n    h(\"pre\", { class: \"stack\", part: \"stack\" }),\n    h(\n      \"div\",\n      { class: \"tip\", part: \"tip\" },\n      \"Click outside, press \",\n      h(\"kbd\", {}, \"Esc\"),\n      \" key, or fix the code to dismiss.\",\n      h(\"br\"),\n      \"You can also disable this overlay by setting \",\n      h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"),\n      \" to \",\n      h(\"code\", { part: \"config-option-value\" }, \"false\"),\n      \" in \",\n      h(\"code\", { part: \"config-file-name\" }, hmrConfigName),\n      \".\"\n    )\n  ),\n  h(\"style\", {}, templateStyle)\n);\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err, links = true) {\n    super();\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.appendChild(createTemplate());\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n    if (err.plugin) {\n      this.text(\".plugin\", `[plugin:${err.plugin}] `);\n    }\n    this.text(\".message-body\", message.trim());\n    const [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n    if (err.loc) {\n      this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n    } else if (err.id) {\n      this.text(\".file\", file);\n    }\n    if (hasFrame) {\n      this.text(\".frame\", err.frame.trim());\n    }\n    this.text(\".stack\", err.stack, links);\n    this.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener(\"click\", () => {\n      this.close();\n    });\n    this.closeOnEsc = (e) => {\n      if (e.key === \"Escape\" || e.code === \"Escape\") {\n        this.close();\n      }\n    };\n    document.addEventListener(\"keydown\", this.closeOnEsc);\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    } else {\n      let curIndex = 0;\n      let match;\n      fileRE.lastIndex = 0;\n      while (match = fileRE.exec(text)) {\n        const { 0: file, index } = match;\n        const frag = text.slice(curIndex, index);\n        el.appendChild(document.createTextNode(frag));\n        const link = document.createElement(\"a\");\n        link.textContent = file;\n        link.className = \"file-link\";\n        link.onclick = () => {\n          fetch(\n            new URL(\n              `${base$1}__open-in-editor?file=${encodeURIComponent(file)}`,\n              import.meta.url\n            )\n          );\n        };\n        el.appendChild(link);\n        curIndex += frag.length + file.length;\n      }\n    }\n  }\n  close() {\n    this.parentNode?.removeChild(this);\n    document.removeEventListener(\"keydown\", this.closeOnEsc);\n  }\n}\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || \"/\";\nconst hmrTimeout = 30000;\nconst wsToken = \"FiU-Pqyvfk9u\";\nconst transport = normalizeModuleRunnerTransport(\n  (() => {\n    let wsTransport = createWebSocketModuleRunnerTransport({\n      createConnection: () => new WebSocket(\n        `${socketProtocol}://${socketHost}?token=${wsToken}`,\n        \"vite-hmr\"\n      ),\n      pingInterval: hmrTimeout\n    });\n    return {\n      async connect(handlers) {\n        try {\n          await wsTransport.connect(handlers);\n        } catch (e) {\n          if (!hmrPort) {\n            wsTransport = createWebSocketModuleRunnerTransport({\n              createConnection: () => new WebSocket(\n                `${socketProtocol}://${directSocketHost}?token=${wsToken}`,\n                \"vite-hmr\"\n              ),\n              pingInterval: hmrTimeout\n            });\n            try {\n              await wsTransport.connect(handlers);\n              console.info(\n                \"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\"\n              );\n            } catch (e2) {\n              if (e2 instanceof Error && e2.message.includes(\"WebSocket closed without opened.\")) {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n                console.error(\n                  `[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`\n                );\n              }\n            }\n            return;\n          }\n          console.error(`[vite] failed to connect to websocket (${e}). `);\n          throw e;\n        }\n      },\n      async disconnect() {\n        await wsTransport.disconnect();\n      },\n      send(data) {\n        wsTransport.send(data);\n      }\n    };\n  })()\n);\nlet willUnload = false;\nif (typeof window !== \"undefined\") {\n  window.addEventListener(\"beforeunload\", () => {\n    willUnload = true;\n  });\n}\nfunction cleanUrl(pathname) {\n  const url = new URL(pathname, \"http://vite.dev\");\n  url.searchParams.delete(\"direct\");\n  return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n  let timer;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      location.reload();\n    }, time);\n  };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(\n  {\n    error: (err) => console.error(\"[vite]\", err),\n    debug: (...msg) => console.debug(\"[vite]\", ...msg)\n  },\n  transport,\n  async function importUpdatedModule({\n    acceptedPath,\n    timestamp,\n    explicitImportRequired,\n    isWithinCircularImport\n  }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n      /* @vite-ignore */\n      base + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`\n    );\n    if (isWithinCircularImport) {\n      importPromise.catch(() => {\n        console.info(\n          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`\n        );\n        pageReload();\n      });\n    }\n    return await importPromise;\n  }\n);\ntransport.connect(createHMRHandler(handleMessage));\nasync function handleMessage(payload) {\n  switch (payload.type) {\n    case \"connected\":\n      console.debug(`[vite] connected.`);\n      break;\n    case \"update\":\n      await hmrClient.notifyListeners(\"vite:beforeUpdate\", payload);\n      if (hasDocument) {\n        if (isFirstUpdate && hasErrorOverlay()) {\n          location.reload();\n          return;\n        } else {\n          if (enableOverlay) {\n            clearErrorOverlay();\n          }\n          isFirstUpdate = false;\n        }\n      }\n      await Promise.all(\n        payload.updates.map(async (update) => {\n          if (update.type === \"js-update\") {\n            return hmrClient.queueUpdate(update);\n          }\n          const { path, timestamp } = update;\n          const searchUrl = cleanUrl(path);\n          const el = Array.from(\n            document.querySelectorAll(\"link\")\n          ).find(\n            (e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl)\n          );\n          if (!el) {\n            return;\n          }\n          const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n          return new Promise((resolve) => {\n            const newLinkTag = el.cloneNode();\n            newLinkTag.href = new URL(newPath, el.href).href;\n            const removeOldEl = () => {\n              el.remove();\n              console.debug(`[vite] css hot updated: ${searchUrl}`);\n              resolve();\n            };\n            newLinkTag.addEventListener(\"load\", removeOldEl);\n            newLinkTag.addEventListener(\"error\", removeOldEl);\n            outdatedLinkTags.add(el);\n            el.after(newLinkTag);\n          });\n        })\n      );\n      await hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n      break;\n    case \"custom\": {\n      await hmrClient.notifyListeners(payload.event, payload.data);\n      if (payload.event === \"vite:ws:disconnect\") {\n        if (hasDocument && !willUnload) {\n          console.log(`[vite] server connection lost. Polling for restart...`);\n          const socket = payload.data.webSocket;\n          const url = new URL(socket.url);\n          url.search = \"\";\n          await waitForSuccessfulPing(url.href);\n          location.reload();\n        }\n      }\n      break;\n    }\n    case \"full-reload\":\n      await hmrClient.notifyListeners(\"vite:beforeFullReload\", payload);\n      if (hasDocument) {\n        if (payload.path && payload.path.endsWith(\".html\")) {\n          const pagePath = decodeURI(location.pathname);\n          const payloadPath = base + payload.path.slice(1);\n          if (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) {\n            pageReload();\n          }\n          return;\n        } else {\n          pageReload();\n        }\n      }\n      break;\n    case \"prune\":\n      await hmrClient.notifyListeners(\"vite:beforePrune\", payload);\n      await hmrClient.prunePaths(payload.paths);\n      break;\n    case \"error\": {\n      await hmrClient.notifyListeners(\"vite:error\", payload);\n      if (hasDocument) {\n        const err = payload.err;\n        if (enableOverlay) {\n          createErrorOverlay(err);\n        } else {\n          console.error(\n            `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n          );\n        }\n      }\n      break;\n    }\n    case \"ping\":\n      break;\n    default: {\n      const check = payload;\n      return check;\n    }\n  }\n}\nconst enableOverlay = true;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n  clearErrorOverlay();\n  const { customElements } = globalThis;\n  if (customElements) {\n    const ErrorOverlayConstructor = customElements.get(overlayId);\n    document.body.appendChild(new ErrorOverlayConstructor(err));\n  }\n}\nfunction clearErrorOverlay() {\n  document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketUrl, ms = 1e3) {\n  async function ping() {\n    const socket = new WebSocket(socketUrl, \"vite-ping\");\n    return new Promise((resolve) => {\n      function onOpen() {\n        resolve(true);\n        close();\n      }\n      function onError() {\n        resolve(false);\n        close();\n      }\n      function close() {\n        socket.removeEventListener(\"open\", onOpen);\n        socket.removeEventListener(\"error\", onError);\n        socket.close();\n      }\n      socket.addEventListener(\"open\", onOpen);\n      socket.addEventListener(\"error\", onError);\n    });\n  }\n  if (await ping()) {\n    return;\n  }\n  await wait(ms);\n  while (true) {\n    if (document.visibilityState === \"visible\") {\n      if (await ping()) {\n        break;\n      }\n      await wait(ms);\n    } else {\n      await waitForWindowShow();\n    }\n  }\n}\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n  return new Promise((resolve) => {\n    const onChange = async () => {\n      if (document.visibilityState === \"visible\") {\n        resolve();\n        document.removeEventListener(\"visibilitychange\", onChange);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onChange);\n  });\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) {\n  document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n    sheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n  });\n}\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    style = document.createElement(\"style\");\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-vite-dev-id\", id);\n    style.textContent = content;\n    if (cspNonce) {\n      style.setAttribute(\"nonce\", cspNonce);\n    }\n    if (!lastInsertedStyle) {\n      document.head.appendChild(style);\n      setTimeout(() => {\n        lastInsertedStyle = void 0;\n      }, 0);\n    } else {\n      lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n    }\n    lastInsertedStyle = style;\n  } else {\n    style.textContent = content;\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n    sheetsMap.delete(id);\n  }\n}\nfunction createHotContext(ownerPath) {\n  return new HMRContext(hmrClient, ownerPath);\n}\nfunction injectQuery(url, queryToInject) {\n  if (url[0] !== \".\" && url[0] !== \"/\") {\n    return url;\n  }\n  const pathname = url.replace(/[?#].*$/, \"\");\n  const { search, hash } = new URL(url, \"http://vite.dev\");\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n",
      "start": 1751856127313,
      "end": 1751856127316,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
