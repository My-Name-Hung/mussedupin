{
  "resolvedId": "C:/Users/.Freelancer/MUSSEEDUPIN/src/components/Home/Collections/Collections.jsx",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { Link } from \"react-router-dom\";\nimport { getImageUrl } from \"../../../utils/cloudinary\";\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\nimport \"./Collections.css\";\n\n// Collections data - memoized to prevent unnecessary re-creation\nconst collectionsData = [\n  {\n    id: 1,\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\n    artist: \"Trưng bày\",\n    image: \"Cồng Chiên.webp\",\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\n    description: {\n      vi: \"Bảo tàng Thông trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\",\n      en: \"Musée Du Pin displays traditional bronze musical instruments of Central Highland ethnic groups, notably the gong - a symbol of sacred culture and beliefs. The resonating sound of gongs represents the deep connection between humans and the spiritual world.\",\n    },\n  },\n  {\n    id: 2,\n    title: \"Hơi thở đại ngàn\",\n    artist: \"Trưng bày\",\n    image: \"Lồng Đa Đa.webp\",\n    alt: \"Hơi thở đại ngàn\",\n    description: {\n      vi: \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Bảo tàng Thông như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\",\n      en: \"The K'ho people's da da cage is currently on display at Musée Du Pin as a rustic yet culturally rich symbol of Central Highland ethnic life. Handwoven from bamboo, the cage not only serves livestock purposes but also reflects the skillfulness, meticulousness, and strong connection between humans and forest nature.\",\n    },\n  },\n  {\n    id: 3,\n    title: \"Hình hài bản sắc\",\n    artist: \"Trưng bày\",\n    image: \"Điêu Khắc.webp\",\n    alt: \"Hình hài bản sắc\",\n    description: {\n      vi: \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Bảo tàng Thông thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa.\",\n      en: \"The K'ho ethnic sculpture currently on display at Musée Du Pin depicts a Highland woman in a solemn stance, holding a small gong - a symbol of indigenous music and beliefs.\",\n    },\n  },\n  {\n    id: 4,\n    title: \"Lửa thiêng đêm núi\",\n    artist: \"Trưng bày\",\n    image: \"36 (2).webp\",\n    alt: \"Lửa thiêng đêm núi\",\n    description:\n      \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\",\n  },\n  {\n    id: 5,\n    title: \"Hơi ấm buôn làng\",\n    artist: \"Tham quan\",\n    image: \"Nồi Đất.webp\",\n    alt: \"Hơi ấm buôn làng\",\n    description:\n      \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\",\n  },\n  {\n    id: 6,\n    title: \"Những mùa no ấm\",\n    artist: \"Tham quan\",\n    image: \"Chiếc Gùi.webp\",\n    alt: \"Những mùa no ấm\",\n    description: \"Chiếc gùi\",\n  },\n  {\n    id: 7,\n    title: \"Phức Tầng\",\n    artist: \"Tham quan\",\n    image: \"Thông 2.webp\",\n    alt: \"Phức Tầng\",\n    description:\n      \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\",\n  },\n  {\n    id: 8,\n    title: \"Vật liệu\",\n    artist: \"Tham quan\",\n    image: \"Hoa Ban Trắng.webp\",\n    alt: \"Vật liệu\",\n    description: \"Vật liệu\",\n  },\n  {\n    id: 9,\n    title: \"Redpine Art Studio\",\n    artist: \"Lưu trú\",\n    image: \"luutrunghethuat.jpg\",\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\n    description:\n      \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\",\n  },\n  {\n    id: 10,\n    title: \"Bề mặt ký ức\",\n    artist: \"Tham quan\",\n    image: \"Lửa.webp\",\n    alt: \"Bề mặt ký ức\",\n    description: \"Bề mặt ký ức.\",\n  },\n  {\n    id: 11,\n    title: \"Thiên nhiên Đà Lạt\",\n    artist: \"Tham quan\",\n    image: \"Gió.webp\",\n    alt: \"Thiên nhiên Đà Lạt\",\n    description: \"Thiên nhiên Đà Lạt.\",\n  },\n  {\n    id: 12,\n    title: \"Sắc màu Tây nguyên\",\n    artist: \"Tham quan\",\n    image: \"Đông.webp\",\n    alt: \"Sắc màu Tây nguyên\",\n    description: \"Sắc màu Tây nguyên.\",\n  },\n];\n\n// Memoized utility functions\nconst getWaveOffset = (index) => {\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\n  return patterns[index % patterns.length];\n};\n\nconst getItemSize = (index) => {\n  const sizes = [\n    { width: 280, height: 320 },\n    { width: 260, height: 340 },\n    { width: 290, height: 300 },\n    { width: 270, height: 330 },\n    { width: 300, height: 310 },\n  ];\n  return sizes[index % sizes.length];\n};\n\nconst Collections = () => {\n  const { currentLang } = useTranslation();\n  const scrollContainerRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastTimestampRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [contentWidth, setContentWidth] = useState(0);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const [isDesktop, setIsDesktop] = useState(false);\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\n  const [touchStartX, setTouchStartX] = useState(0);\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\n  const [lastTouchX, setLastTouchX] = useState(0);\n  const [lastTouchTime, setLastTouchTime] = useState(0);\n  const [touchVelocity, setTouchVelocity] = useState(0);\n\n  // Optimized device type detection with debounce\n  useEffect(() => {\n    let timeoutId;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const width = window.innerWidth;\n        setIsMobile(width <= 768);\n        setIsDesktop(width >= 1200);\n      }, 100);\n    };\n\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n\n    // Hide swipe hint after 5 seconds on mobile\n    if (isMobile) {\n      const timer = setTimeout(() => {\n        setShowSwipeHint(false);\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      clearTimeout(timeoutId);\n    };\n  }, [isMobile]);\n\n  // Optimized intersection observer\n  const handleVisibilityChange = useCallback((entries) => {\n    const entry = entries[0];\n    if (entry.isIntersecting) {\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\n      if (ratio > 0.2) {\n        setIsVisible(true);\n      }\n    } else if (entry.intersectionRatio === 0) {\n      setIsVisible(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    const options = {\n      threshold: [0.1, 0.2, 0.5, 0.8],\n      rootMargin: \"0px 0px 100px 0px\",\n    };\n\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\n\n    if (scrollContainerRef.current) {\n      observer.observe(scrollContainerRef.current);\n    }\n\n    return () => {\n      if (scrollContainerRef.current) {\n        observer.unobserve(scrollContainerRef.current);\n      }\n    };\n  }, [handleVisibilityChange]);\n\n  // Calculate widths for scroll animation with ResizeObserver\n  useEffect(() => {\n    if (!scrollContainerRef.current) return;\n\n    const calculateWidths = () => {\n      if (scrollContainerRef.current) {\n        const containerWidth = scrollContainerRef.current.clientWidth;\n        const contentWidth = scrollContainerRef.current.scrollWidth;\n\n        setContainerWidth(containerWidth);\n        setContentWidth(contentWidth);\n      }\n    };\n\n    if (window.ResizeObserver) {\n      const resizeObserver = new ResizeObserver(calculateWidths);\n      resizeObserver.observe(scrollContainerRef.current);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    } else {\n      calculateWidths();\n\n      let debounceTimer;\n      const handleResize = () => {\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(calculateWidths, 100);\n      };\n\n      window.addEventListener(\"resize\", handleResize);\n\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n        clearTimeout(debounceTimer);\n      };\n    }\n  }, []);\n\n  // Update scroll position with hardware acceleration\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      const transform = `translateX(-${scrollPosition}px)`;\n      scrollContainerRef.current.style.transform = transform;\n      scrollContainerRef.current.style.willChange = \"transform\";\n    }\n  }, [scrollPosition]);\n\n  // Enhanced auto-scroll animation with consistent speed\n  useEffect(() => {\n    if (!isVisible || isPaused) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      return;\n    }\n\n    // Set constant speed for different devices\n    const baseScrollSpeed = isMobile ? 0.8 : isDesktop ? 1.2 : 1;\n    const maxScroll = contentWidth - containerWidth;\n    let lastScrollTime = performance.now();\n\n    const animate = (timestamp) => {\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\n      const currentTime = performance.now();\n      const timeDiff = currentTime - lastScrollTime;\n\n      // Keep consistent frame timing\n      const frameMultiplier = Math.min(timeDiff / 16.67, 2);\n      const scrollSpeed = baseScrollSpeed * frameMultiplier;\n\n      setScrollPosition((prevPosition) => {\n        const newPosition = prevPosition + scrollSpeed;\n\n        // Reset position when reaching the end\n        if (newPosition >= maxScroll) {\n          return 0;\n        }\n        return newPosition;\n      });\n\n      lastTimestampRef.current = timestamp;\n      lastScrollTime = currentTime;\n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    animationRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      lastTimestampRef.current = null;\n    };\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\n\n  // Memoized event handlers for better performance\n  const handleItemHover = useCallback(\n    (index) => {\n      if (isDesktop) {\n        setHoverItemIndex(index);\n      }\n    },\n    [isDesktop]\n  );\n\n  const handleItemLeave = useCallback(() => {\n    if (isDesktop) {\n      setHoverItemIndex(null);\n    }\n  }, [isDesktop]);\n\n  // Update mouse event handlers\n  const handleMouseEnter = useCallback(() => {\n    if (!isMobile) {\n      setIsPaused(true);\n    }\n  }, [isMobile]);\n\n  const handleMouseLeave = useCallback(() => {\n    if (!isMobile) {\n      // Shorter delay for smoother transition\n      setTimeout(() => setIsPaused(false), 50);\n    }\n  }, [isMobile]);\n\n  // Enhanced touch handling with better performance\n  const handleTouchStart = useCallback((e) => {\n    setIsPaused(true);\n    setIsUserInteracting(true);\n    setTouchStartX(e.touches[0].clientX);\n    setLastTouchX(e.touches[0].clientX);\n    setLastTouchTime(Date.now());\n    setShowSwipeHint(false);\n  }, []);\n\n  const handleTouchEnd = useCallback(() => {\n    setIsUserInteracting(false);\n\n    if (Math.abs(touchVelocity) > 0.3) {\n      // Reduced threshold for more responsive feel\n      const momentum = touchVelocity * 120; // Increased multiplier\n      const targetScroll = scrollPosition + momentum;\n      const startScroll = scrollPosition;\n      const startTime = performance.now();\n      const duration = Math.min(Math.abs(momentum) * 2, 800); // Dynamic duration\n\n      const animateMomentum = () => {\n        const elapsed = performance.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Enhanced easing function\n        const easeOutExpo = (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n        const currentProgress = easeOutExpo(progress);\n\n        const newScroll =\n          startScroll + (targetScroll - startScroll) * currentProgress;\n\n        setScrollPosition(\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\n        );\n\n        if (progress < 1) {\n          requestAnimationFrame(animateMomentum);\n        } else {\n          setTimeout(() => setIsPaused(false), 500);\n        }\n      };\n\n      requestAnimationFrame(animateMomentum);\n    } else {\n      setTimeout(() => setIsPaused(false), 500);\n    }\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\n\n  const handleTouchMove = useCallback(\n    (e) => {\n      if (isUserInteracting && scrollContainerRef.current) {\n        const touchX = e.touches[0].clientX;\n        const diff = touchStartX - touchX;\n        const now = performance.now();\n        const deltaTime = now - lastTouchTime;\n        const deltaX = touchX - lastTouchX;\n\n        // Improved velocity calculation\n        const newVelocity = deltaX / Math.max(deltaTime, 1);\n        setTouchVelocity(newVelocity * 1.5); // Increased multiplier for smoother momentum\n\n        setLastTouchX(touchX);\n        setLastTouchTime(now);\n\n        setScrollPosition((prev) => {\n          const sensitivity = isMobile ? 1.5 : 1.2;\n          const newPosition = prev + diff * sensitivity;\n          setTouchStartX(touchX);\n\n          // Enhanced elastic boundaries\n          if (newPosition < 0) {\n            return Math.max(newPosition * 0.3, -containerWidth * 0.1);\n          }\n          if (newPosition > contentWidth - containerWidth) {\n            const overscroll = newPosition - (contentWidth - containerWidth);\n            return contentWidth - containerWidth + overscroll * 0.3;\n          }\n\n          return newPosition;\n        });\n      }\n    },\n    [\n      isUserInteracting,\n      touchStartX,\n      lastTouchTime,\n      lastTouchX,\n      containerWidth,\n      contentWidth,\n      isMobile,\n    ]\n  );\n\n  // Memoized collection items\n  const collectionItems = useMemo(() => {\n    return collectionsData.map((item, index) => {\n      const waveOffset = getWaveOffset(index);\n      const itemSize = getItemSize(index);\n\n      return (\n        <div\n          key={item.id}\n          className={`collection-item ${\n            hoverItemIndex === index ? \"item-hovered\" : \"\"\n          }`}\n          style={{\n            animationDelay: `${index * 0.1}s`,\n            transform: `translateY(${waveOffset}px)`,\n            width: `${itemSize.width}px`,\n            height: `${itemSize.height}px`,\n            transition: \"transform 0.5s ease, scale 0.3s ease\",\n          }}\n          onMouseEnter={() => handleItemHover(index)}\n          onMouseLeave={handleItemLeave}\n        >\n          <Link to=\"/collection\" className=\"collection-link\">\n            <div className=\"collection-image-wrapper\">\n              <OptimizedImage\n                src={getImageUrl(item.image)}\n                alt={item.alt}\n                className=\"collection-image\"\n                priority={index < 5}\n                width={itemSize.width}\n                height={itemSize.height}\n                sizes=\"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\n              />\n              <div className=\"collection-overlay\">\n                <div className=\"collection-info\">\n                  <h3 className=\"collection-title\">{item.title}</h3>\n                  <p className=\"collection-artist\">{item.artist}</p>\n                </div>\n              </div>\n            </div>\n          </Link>\n        </div>\n      );\n    });\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\n\n  return (\n    <section className=\"collections-section\" id=\"collections\">\n      <div className=\"collections-content-container\">\n        <div className=\"collections-header\">\n          <h3 className=\"collections-title\">Bộ sưu tập</h3>\n          {isDesktop && (\n            <p className=\"collections-subtitle\">\n              Khám phá bộ sưu tập nghệ thuật\n            </p>\n          )}\n        </div>\n\n        <div\n          className={`collections-gallery-container ${\n            isVisible ? \"visible\" : \"\"\n          } ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`}\n        >\n          {isDesktop && <div className=\"shadow-effect\"></div>}\n          {isDesktop && <div className=\"left-fade\"></div>}\n\n          {isMobile && showSwipeHint && (\n            <div className=\"swipe-hint\">\n              <span className=\"swipe-text\">\n                Trượt để khám phá\n                <svg\n                  viewBox=\"0 0 24 24\"\n                  fill=\"none\"\n                  height=\"18\"\n                  width=\"18\"\n                  stroke=\"currentColor\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth=\"2\"\n                    d=\"M9 5l7 7-7 7\"\n                  ></path>\n                </svg>\n              </span>\n            </div>\n          )}\n\n          <div\n            className=\"collections-gallery\"\n            ref={scrollContainerRef}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n            onTouchStart={handleTouchStart}\n            onTouchEnd={handleTouchEnd}\n            onTouchMove={handleTouchMove}\n            style={isMobile ? { overflow: \"visible\" } : {}}\n          >\n            <div className=\"collection-inner-container\">{collectionItems}</div>\n          </div>\n        </div>\n\n        <div className=\"collections-footer\">\n          <Link to=\"/collection\" className=\"view-all-links\">\n            Xem tất cả bộ sưu tập\n            <span className=\"arrow-icon\">→</span>\n          </Link>\n        </div>\n      </div>\n    </section>\n  );\n};\n\nexport default React.memo(Collections);\n",
      "start": 1751956260789,
      "end": 1751956261066,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1751956261066,
      "end": 1751956261066,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "result": "import { jsx, jsxs } from \"react/jsx-runtime\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { Link } from \"react-router-dom\";\nimport { getImageUrl } from \"../../../utils/cloudinary\";\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\nimport \"./Collections.css\";\nconst collectionsData = [\n  {\n    id: 1,\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\n    artist: \"Trưng bày\",\n    image: \"Cồng Chiên.webp\",\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\n    description: {\n      vi: \"Bảo tàng Thông trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\",\n      en: \"Musée Du Pin displays traditional bronze musical instruments of Central Highland ethnic groups, notably the gong - a symbol of sacred culture and beliefs. The resonating sound of gongs represents the deep connection between humans and the spiritual world.\"\n    }\n  },\n  {\n    id: 2,\n    title: \"Hơi thở đại ngàn\",\n    artist: \"Trưng bày\",\n    image: \"Lồng Đa Đa.webp\",\n    alt: \"Hơi thở đại ngàn\",\n    description: {\n      vi: \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Bảo tàng Thông như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\",\n      en: \"The K'ho people's da da cage is currently on display at Musée Du Pin as a rustic yet culturally rich symbol of Central Highland ethnic life. Handwoven from bamboo, the cage not only serves livestock purposes but also reflects the skillfulness, meticulousness, and strong connection between humans and forest nature.\"\n    }\n  },\n  {\n    id: 3,\n    title: \"Hình hài bản sắc\",\n    artist: \"Trưng bày\",\n    image: \"Điêu Khắc.webp\",\n    alt: \"Hình hài bản sắc\",\n    description: {\n      vi: \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Bảo tàng Thông thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa.\",\n      en: \"The K'ho ethnic sculpture currently on display at Musée Du Pin depicts a Highland woman in a solemn stance, holding a small gong - a symbol of indigenous music and beliefs.\"\n    }\n  },\n  {\n    id: 4,\n    title: \"Lửa thiêng đêm núi\",\n    artist: \"Trưng bày\",\n    image: \"36 (2).webp\",\n    alt: \"Lửa thiêng đêm núi\",\n    description: \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\"\n  },\n  {\n    id: 5,\n    title: \"Hơi ấm buôn làng\",\n    artist: \"Tham quan\",\n    image: \"Nồi Đất.webp\",\n    alt: \"Hơi ấm buôn làng\",\n    description: \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\"\n  },\n  {\n    id: 6,\n    title: \"Những mùa no ấm\",\n    artist: \"Tham quan\",\n    image: \"Chiếc Gùi.webp\",\n    alt: \"Những mùa no ấm\",\n    description: \"Chiếc gùi\"\n  },\n  {\n    id: 7,\n    title: \"Phức Tầng\",\n    artist: \"Tham quan\",\n    image: \"Thông 2.webp\",\n    alt: \"Phức Tầng\",\n    description: \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\"\n  },\n  {\n    id: 8,\n    title: \"Vật liệu\",\n    artist: \"Tham quan\",\n    image: \"Hoa Ban Trắng.webp\",\n    alt: \"Vật liệu\",\n    description: \"Vật liệu\"\n  },\n  {\n    id: 9,\n    title: \"Redpine Art Studio\",\n    artist: \"Lưu trú\",\n    image: \"luutrunghethuat.jpg\",\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\n    description: \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\"\n  },\n  {\n    id: 10,\n    title: \"Bề mặt ký ức\",\n    artist: \"Tham quan\",\n    image: \"Lửa.webp\",\n    alt: \"Bề mặt ký ức\",\n    description: \"Bề mặt ký ức.\"\n  },\n  {\n    id: 11,\n    title: \"Thiên nhiên Đà Lạt\",\n    artist: \"Tham quan\",\n    image: \"Gió.webp\",\n    alt: \"Thiên nhiên Đà Lạt\",\n    description: \"Thiên nhiên Đà Lạt.\"\n  },\n  {\n    id: 12,\n    title: \"Sắc màu Tây nguyên\",\n    artist: \"Tham quan\",\n    image: \"Đông.webp\",\n    alt: \"Sắc màu Tây nguyên\",\n    description: \"Sắc màu Tây nguyên.\"\n  }\n];\nconst getWaveOffset = (index) => {\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\n  return patterns[index % patterns.length];\n};\nconst getItemSize = (index) => {\n  const sizes = [\n    { width: 280, height: 320 },\n    { width: 260, height: 340 },\n    { width: 290, height: 300 },\n    { width: 270, height: 330 },\n    { width: 300, height: 310 }\n  ];\n  return sizes[index % sizes.length];\n};\nconst Collections = () => {\n  const { currentLang } = useTranslation();\n  const scrollContainerRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastTimestampRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [contentWidth, setContentWidth] = useState(0);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const [isDesktop, setIsDesktop] = useState(false);\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\n  const [touchStartX, setTouchStartX] = useState(0);\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\n  const [lastTouchX, setLastTouchX] = useState(0);\n  const [lastTouchTime, setLastTouchTime] = useState(0);\n  const [touchVelocity, setTouchVelocity] = useState(0);\n  useEffect(() => {\n    let timeoutId;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const width = window.innerWidth;\n        setIsMobile(width <= 768);\n        setIsDesktop(width >= 1200);\n      }, 100);\n    };\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n    if (isMobile) {\n      const timer = setTimeout(() => {\n        setShowSwipeHint(false);\n      }, 5e3);\n      return () => clearTimeout(timer);\n    }\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      clearTimeout(timeoutId);\n    };\n  }, [isMobile]);\n  const handleVisibilityChange = useCallback((entries) => {\n    const entry = entries[0];\n    if (entry.isIntersecting) {\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\n      if (ratio > 0.2) {\n        setIsVisible(true);\n      }\n    } else if (entry.intersectionRatio === 0) {\n      setIsVisible(false);\n    }\n  }, []);\n  useEffect(() => {\n    const options = {\n      threshold: [0.1, 0.2, 0.5, 0.8],\n      rootMargin: \"0px 0px 100px 0px\"\n    };\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\n    if (scrollContainerRef.current) {\n      observer.observe(scrollContainerRef.current);\n    }\n    return () => {\n      if (scrollContainerRef.current) {\n        observer.unobserve(scrollContainerRef.current);\n      }\n    };\n  }, [handleVisibilityChange]);\n  useEffect(() => {\n    if (!scrollContainerRef.current) return;\n    const calculateWidths = () => {\n      if (scrollContainerRef.current) {\n        const containerWidth2 = scrollContainerRef.current.clientWidth;\n        const contentWidth2 = scrollContainerRef.current.scrollWidth;\n        setContainerWidth(containerWidth2);\n        setContentWidth(contentWidth2);\n      }\n    };\n    if (window.ResizeObserver) {\n      const resizeObserver = new ResizeObserver(calculateWidths);\n      resizeObserver.observe(scrollContainerRef.current);\n      return () => {\n        resizeObserver.disconnect();\n      };\n    } else {\n      calculateWidths();\n      let debounceTimer;\n      const handleResize = () => {\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(calculateWidths, 100);\n      };\n      window.addEventListener(\"resize\", handleResize);\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n        clearTimeout(debounceTimer);\n      };\n    }\n  }, []);\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      const transform = `translateX(-${scrollPosition}px)`;\n      scrollContainerRef.current.style.transform = transform;\n      scrollContainerRef.current.style.willChange = \"transform\";\n    }\n  }, [scrollPosition]);\n  useEffect(() => {\n    if (!isVisible || isPaused) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      return;\n    }\n    const baseScrollSpeed = isMobile ? 0.8 : isDesktop ? 1.2 : 1;\n    const maxScroll = contentWidth - containerWidth;\n    let lastScrollTime = performance.now();\n    const animate = (timestamp) => {\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\n      const currentTime = performance.now();\n      const timeDiff = currentTime - lastScrollTime;\n      const frameMultiplier = Math.min(timeDiff / 16.67, 2);\n      const scrollSpeed = baseScrollSpeed * frameMultiplier;\n      setScrollPosition((prevPosition) => {\n        const newPosition = prevPosition + scrollSpeed;\n        if (newPosition >= maxScroll) {\n          return 0;\n        }\n        return newPosition;\n      });\n      lastTimestampRef.current = timestamp;\n      lastScrollTime = currentTime;\n      animationRef.current = requestAnimationFrame(animate);\n    };\n    animationRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      lastTimestampRef.current = null;\n    };\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\n  const handleItemHover = useCallback(\n    (index) => {\n      if (isDesktop) {\n        setHoverItemIndex(index);\n      }\n    },\n    [isDesktop]\n  );\n  const handleItemLeave = useCallback(() => {\n    if (isDesktop) {\n      setHoverItemIndex(null);\n    }\n  }, [isDesktop]);\n  const handleMouseEnter = useCallback(() => {\n    if (!isMobile) {\n      setIsPaused(true);\n    }\n  }, [isMobile]);\n  const handleMouseLeave = useCallback(() => {\n    if (!isMobile) {\n      setTimeout(() => setIsPaused(false), 50);\n    }\n  }, [isMobile]);\n  const handleTouchStart = useCallback((e) => {\n    setIsPaused(true);\n    setIsUserInteracting(true);\n    setTouchStartX(e.touches[0].clientX);\n    setLastTouchX(e.touches[0].clientX);\n    setLastTouchTime(Date.now());\n    setShowSwipeHint(false);\n  }, []);\n  const handleTouchEnd = useCallback(() => {\n    setIsUserInteracting(false);\n    if (Math.abs(touchVelocity) > 0.3) {\n      const momentum = touchVelocity * 120;\n      const targetScroll = scrollPosition + momentum;\n      const startScroll = scrollPosition;\n      const startTime = performance.now();\n      const duration = Math.min(Math.abs(momentum) * 2, 800);\n      const animateMomentum = () => {\n        const elapsed = performance.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n        const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);\n        const currentProgress = easeOutExpo(progress);\n        const newScroll = startScroll + (targetScroll - startScroll) * currentProgress;\n        setScrollPosition(\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\n        );\n        if (progress < 1) {\n          requestAnimationFrame(animateMomentum);\n        } else {\n          setTimeout(() => setIsPaused(false), 500);\n        }\n      };\n      requestAnimationFrame(animateMomentum);\n    } else {\n      setTimeout(() => setIsPaused(false), 500);\n    }\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\n  const handleTouchMove = useCallback(\n    (e) => {\n      if (isUserInteracting && scrollContainerRef.current) {\n        const touchX = e.touches[0].clientX;\n        const diff = touchStartX - touchX;\n        const now = performance.now();\n        const deltaTime = now - lastTouchTime;\n        const deltaX = touchX - lastTouchX;\n        const newVelocity = deltaX / Math.max(deltaTime, 1);\n        setTouchVelocity(newVelocity * 1.5);\n        setLastTouchX(touchX);\n        setLastTouchTime(now);\n        setScrollPosition((prev) => {\n          const sensitivity = isMobile ? 1.5 : 1.2;\n          const newPosition = prev + diff * sensitivity;\n          setTouchStartX(touchX);\n          if (newPosition < 0) {\n            return Math.max(newPosition * 0.3, -containerWidth * 0.1);\n          }\n          if (newPosition > contentWidth - containerWidth) {\n            const overscroll = newPosition - (contentWidth - containerWidth);\n            return contentWidth - containerWidth + overscroll * 0.3;\n          }\n          return newPosition;\n        });\n      }\n    },\n    [\n      isUserInteracting,\n      touchStartX,\n      lastTouchTime,\n      lastTouchX,\n      containerWidth,\n      contentWidth,\n      isMobile\n    ]\n  );\n  const collectionItems = useMemo(() => {\n    return collectionsData.map((item, index) => {\n      const waveOffset = getWaveOffset(index);\n      const itemSize = getItemSize(index);\n      return /* @__PURE__ */ jsx(\n        \"div\",\n        {\n          className: `collection-item ${hoverItemIndex === index ? \"item-hovered\" : \"\"}`,\n          style: {\n            animationDelay: `${index * 0.1}s`,\n            transform: `translateY(${waveOffset}px)`,\n            width: `${itemSize.width}px`,\n            height: `${itemSize.height}px`,\n            transition: \"transform 0.5s ease, scale 0.3s ease\"\n          },\n          onMouseEnter: () => handleItemHover(index),\n          onMouseLeave: handleItemLeave,\n          children: /* @__PURE__ */ jsx(Link, { to: \"/collection\", className: \"collection-link\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collection-image-wrapper\", children: [\n            /* @__PURE__ */ jsx(\n              OptimizedImage,\n              {\n                src: getImageUrl(item.image),\n                alt: item.alt,\n                className: \"collection-image\",\n                priority: index < 5,\n                width: itemSize.width,\n                height: itemSize.height,\n                sizes: \"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\n              }\n            ),\n            /* @__PURE__ */ jsx(\"div\", { className: \"collection-overlay\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collection-info\", children: [\n              /* @__PURE__ */ jsx(\"h3\", { className: \"collection-title\", children: item.title }),\n              /* @__PURE__ */ jsx(\"p\", { className: \"collection-artist\", children: item.artist })\n            ] }) })\n          ] }) })\n        },\n        item.id\n      );\n    });\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\n  return /* @__PURE__ */ jsx(\"section\", { className: \"collections-section\", id: \"collections\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collections-content-container\", children: [\n    /* @__PURE__ */ jsxs(\"div\", { className: \"collections-header\", children: [\n      /* @__PURE__ */ jsx(\"h3\", { className: \"collections-title\", children: \"Bộ sưu tập\" }),\n      isDesktop && /* @__PURE__ */ jsx(\"p\", { className: \"collections-subtitle\", children: \"Khám phá bộ sưu tập nghệ thuật\" })\n    ] }),\n    /* @__PURE__ */ jsxs(\n      \"div\",\n      {\n        className: `collections-gallery-container ${isVisible ? \"visible\" : \"\"} ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`,\n        children: [\n          isDesktop && /* @__PURE__ */ jsx(\"div\", { className: \"shadow-effect\" }),\n          isDesktop && /* @__PURE__ */ jsx(\"div\", { className: \"left-fade\" }),\n          isMobile && showSwipeHint && /* @__PURE__ */ jsx(\"div\", { className: \"swipe-hint\", children: /* @__PURE__ */ jsxs(\"span\", { className: \"swipe-text\", children: [\n            \"Trượt để khám phá\",\n            /* @__PURE__ */ jsx(\n              \"svg\",\n              {\n                viewBox: \"0 0 24 24\",\n                fill: \"none\",\n                height: \"18\",\n                width: \"18\",\n                stroke: \"currentColor\",\n                children: /* @__PURE__ */ jsx(\n                  \"path\",\n                  {\n                    strokeLinecap: \"round\",\n                    strokeLinejoin: \"round\",\n                    strokeWidth: \"2\",\n                    d: \"M9 5l7 7-7 7\"\n                  }\n                )\n              }\n            )\n          ] }) }),\n          /* @__PURE__ */ jsx(\n            \"div\",\n            {\n              className: \"collections-gallery\",\n              ref: scrollContainerRef,\n              onMouseEnter: handleMouseEnter,\n              onMouseLeave: handleMouseLeave,\n              onTouchStart: handleTouchStart,\n              onTouchEnd: handleTouchEnd,\n              onTouchMove: handleTouchMove,\n              style: isMobile ? { overflow: \"visible\" } : {},\n              children: /* @__PURE__ */ jsx(\"div\", { className: \"collection-inner-container\", children: collectionItems })\n            }\n          )\n        ]\n      }\n    ),\n    /* @__PURE__ */ jsx(\"div\", { className: \"collections-footer\", children: /* @__PURE__ */ jsxs(Link, { to: \"/collection\", className: \"view-all-links\", children: [\n      \"Xem tất cả bộ sưu tập\",\n      /* @__PURE__ */ jsx(\"span\", { className: \"arrow-icon\", children: \"→\" })\n    ] }) })\n  ] }) });\n};\nexport default React.memo(Collections);\n",
      "start": 1751956261066,
      "end": 1751956273950,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "C:/Users/.Freelancer/MUSSEEDUPIN/src/components/Home/Collections/Collections.jsx"
        ],
        "sourcesContent": [
          "import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { Link } from \"react-router-dom\";\nimport { getImageUrl } from \"../../../utils/cloudinary\";\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\nimport \"./Collections.css\";\n\n// Collections data - memoized to prevent unnecessary re-creation\nconst collectionsData = [\n  {\n    id: 1,\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\n    artist: \"Trưng bày\",\n    image: \"Cồng Chiên.webp\",\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\n    description: {\n      vi: \"Bảo tàng Thông trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\",\n      en: \"Musée Du Pin displays traditional bronze musical instruments of Central Highland ethnic groups, notably the gong - a symbol of sacred culture and beliefs. The resonating sound of gongs represents the deep connection between humans and the spiritual world.\",\n    },\n  },\n  {\n    id: 2,\n    title: \"Hơi thở đại ngàn\",\n    artist: \"Trưng bày\",\n    image: \"Lồng Đa Đa.webp\",\n    alt: \"Hơi thở đại ngàn\",\n    description: {\n      vi: \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Bảo tàng Thông như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\",\n      en: \"The K'ho people's da da cage is currently on display at Musée Du Pin as a rustic yet culturally rich symbol of Central Highland ethnic life. Handwoven from bamboo, the cage not only serves livestock purposes but also reflects the skillfulness, meticulousness, and strong connection between humans and forest nature.\",\n    },\n  },\n  {\n    id: 3,\n    title: \"Hình hài bản sắc\",\n    artist: \"Trưng bày\",\n    image: \"Điêu Khắc.webp\",\n    alt: \"Hình hài bản sắc\",\n    description: {\n      vi: \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Bảo tàng Thông thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa.\",\n      en: \"The K'ho ethnic sculpture currently on display at Musée Du Pin depicts a Highland woman in a solemn stance, holding a small gong - a symbol of indigenous music and beliefs.\",\n    },\n  },\n  {\n    id: 4,\n    title: \"Lửa thiêng đêm núi\",\n    artist: \"Trưng bày\",\n    image: \"36 (2).webp\",\n    alt: \"Lửa thiêng đêm núi\",\n    description:\n      \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\",\n  },\n  {\n    id: 5,\n    title: \"Hơi ấm buôn làng\",\n    artist: \"Tham quan\",\n    image: \"Nồi Đất.webp\",\n    alt: \"Hơi ấm buôn làng\",\n    description:\n      \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\",\n  },\n  {\n    id: 6,\n    title: \"Những mùa no ấm\",\n    artist: \"Tham quan\",\n    image: \"Chiếc Gùi.webp\",\n    alt: \"Những mùa no ấm\",\n    description: \"Chiếc gùi\",\n  },\n  {\n    id: 7,\n    title: \"Phức Tầng\",\n    artist: \"Tham quan\",\n    image: \"Thông 2.webp\",\n    alt: \"Phức Tầng\",\n    description:\n      \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\",\n  },\n  {\n    id: 8,\n    title: \"Vật liệu\",\n    artist: \"Tham quan\",\n    image: \"Hoa Ban Trắng.webp\",\n    alt: \"Vật liệu\",\n    description: \"Vật liệu\",\n  },\n  {\n    id: 9,\n    title: \"Redpine Art Studio\",\n    artist: \"Lưu trú\",\n    image: \"luutrunghethuat.jpg\",\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\n    description:\n      \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\",\n  },\n  {\n    id: 10,\n    title: \"Bề mặt ký ức\",\n    artist: \"Tham quan\",\n    image: \"Lửa.webp\",\n    alt: \"Bề mặt ký ức\",\n    description: \"Bề mặt ký ức.\",\n  },\n  {\n    id: 11,\n    title: \"Thiên nhiên Đà Lạt\",\n    artist: \"Tham quan\",\n    image: \"Gió.webp\",\n    alt: \"Thiên nhiên Đà Lạt\",\n    description: \"Thiên nhiên Đà Lạt.\",\n  },\n  {\n    id: 12,\n    title: \"Sắc màu Tây nguyên\",\n    artist: \"Tham quan\",\n    image: \"Đông.webp\",\n    alt: \"Sắc màu Tây nguyên\",\n    description: \"Sắc màu Tây nguyên.\",\n  },\n];\n\n// Memoized utility functions\nconst getWaveOffset = (index) => {\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\n  return patterns[index % patterns.length];\n};\n\nconst getItemSize = (index) => {\n  const sizes = [\n    { width: 280, height: 320 },\n    { width: 260, height: 340 },\n    { width: 290, height: 300 },\n    { width: 270, height: 330 },\n    { width: 300, height: 310 },\n  ];\n  return sizes[index % sizes.length];\n};\n\nconst Collections = () => {\n  const { currentLang } = useTranslation();\n  const scrollContainerRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastTimestampRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [contentWidth, setContentWidth] = useState(0);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const [isDesktop, setIsDesktop] = useState(false);\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\n  const [touchStartX, setTouchStartX] = useState(0);\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\n  const [lastTouchX, setLastTouchX] = useState(0);\n  const [lastTouchTime, setLastTouchTime] = useState(0);\n  const [touchVelocity, setTouchVelocity] = useState(0);\n\n  // Optimized device type detection with debounce\n  useEffect(() => {\n    let timeoutId;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const width = window.innerWidth;\n        setIsMobile(width <= 768);\n        setIsDesktop(width >= 1200);\n      }, 100);\n    };\n\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n\n    // Hide swipe hint after 5 seconds on mobile\n    if (isMobile) {\n      const timer = setTimeout(() => {\n        setShowSwipeHint(false);\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      clearTimeout(timeoutId);\n    };\n  }, [isMobile]);\n\n  // Optimized intersection observer\n  const handleVisibilityChange = useCallback((entries) => {\n    const entry = entries[0];\n    if (entry.isIntersecting) {\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\n      if (ratio > 0.2) {\n        setIsVisible(true);\n      }\n    } else if (entry.intersectionRatio === 0) {\n      setIsVisible(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    const options = {\n      threshold: [0.1, 0.2, 0.5, 0.8],\n      rootMargin: \"0px 0px 100px 0px\",\n    };\n\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\n\n    if (scrollContainerRef.current) {\n      observer.observe(scrollContainerRef.current);\n    }\n\n    return () => {\n      if (scrollContainerRef.current) {\n        observer.unobserve(scrollContainerRef.current);\n      }\n    };\n  }, [handleVisibilityChange]);\n\n  // Calculate widths for scroll animation with ResizeObserver\n  useEffect(() => {\n    if (!scrollContainerRef.current) return;\n\n    const calculateWidths = () => {\n      if (scrollContainerRef.current) {\n        const containerWidth = scrollContainerRef.current.clientWidth;\n        const contentWidth = scrollContainerRef.current.scrollWidth;\n\n        setContainerWidth(containerWidth);\n        setContentWidth(contentWidth);\n      }\n    };\n\n    if (window.ResizeObserver) {\n      const resizeObserver = new ResizeObserver(calculateWidths);\n      resizeObserver.observe(scrollContainerRef.current);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    } else {\n      calculateWidths();\n\n      let debounceTimer;\n      const handleResize = () => {\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(calculateWidths, 100);\n      };\n\n      window.addEventListener(\"resize\", handleResize);\n\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n        clearTimeout(debounceTimer);\n      };\n    }\n  }, []);\n\n  // Update scroll position with hardware acceleration\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      const transform = `translateX(-${scrollPosition}px)`;\n      scrollContainerRef.current.style.transform = transform;\n      scrollContainerRef.current.style.willChange = \"transform\";\n    }\n  }, [scrollPosition]);\n\n  // Enhanced auto-scroll animation with consistent speed\n  useEffect(() => {\n    if (!isVisible || isPaused) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      return;\n    }\n\n    // Set constant speed for different devices\n    const baseScrollSpeed = isMobile ? 0.8 : isDesktop ? 1.2 : 1;\n    const maxScroll = contentWidth - containerWidth;\n    let lastScrollTime = performance.now();\n\n    const animate = (timestamp) => {\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\n      const currentTime = performance.now();\n      const timeDiff = currentTime - lastScrollTime;\n\n      // Keep consistent frame timing\n      const frameMultiplier = Math.min(timeDiff / 16.67, 2);\n      const scrollSpeed = baseScrollSpeed * frameMultiplier;\n\n      setScrollPosition((prevPosition) => {\n        const newPosition = prevPosition + scrollSpeed;\n\n        // Reset position when reaching the end\n        if (newPosition >= maxScroll) {\n          return 0;\n        }\n        return newPosition;\n      });\n\n      lastTimestampRef.current = timestamp;\n      lastScrollTime = currentTime;\n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    animationRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      lastTimestampRef.current = null;\n    };\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\n\n  // Memoized event handlers for better performance\n  const handleItemHover = useCallback(\n    (index) => {\n      if (isDesktop) {\n        setHoverItemIndex(index);\n      }\n    },\n    [isDesktop]\n  );\n\n  const handleItemLeave = useCallback(() => {\n    if (isDesktop) {\n      setHoverItemIndex(null);\n    }\n  }, [isDesktop]);\n\n  // Update mouse event handlers\n  const handleMouseEnter = useCallback(() => {\n    if (!isMobile) {\n      setIsPaused(true);\n    }\n  }, [isMobile]);\n\n  const handleMouseLeave = useCallback(() => {\n    if (!isMobile) {\n      // Shorter delay for smoother transition\n      setTimeout(() => setIsPaused(false), 50);\n    }\n  }, [isMobile]);\n\n  // Enhanced touch handling with better performance\n  const handleTouchStart = useCallback((e) => {\n    setIsPaused(true);\n    setIsUserInteracting(true);\n    setTouchStartX(e.touches[0].clientX);\n    setLastTouchX(e.touches[0].clientX);\n    setLastTouchTime(Date.now());\n    setShowSwipeHint(false);\n  }, []);\n\n  const handleTouchEnd = useCallback(() => {\n    setIsUserInteracting(false);\n\n    if (Math.abs(touchVelocity) > 0.3) {\n      // Reduced threshold for more responsive feel\n      const momentum = touchVelocity * 120; // Increased multiplier\n      const targetScroll = scrollPosition + momentum;\n      const startScroll = scrollPosition;\n      const startTime = performance.now();\n      const duration = Math.min(Math.abs(momentum) * 2, 800); // Dynamic duration\n\n      const animateMomentum = () => {\n        const elapsed = performance.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Enhanced easing function\n        const easeOutExpo = (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n        const currentProgress = easeOutExpo(progress);\n\n        const newScroll =\n          startScroll + (targetScroll - startScroll) * currentProgress;\n\n        setScrollPosition(\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\n        );\n\n        if (progress < 1) {\n          requestAnimationFrame(animateMomentum);\n        } else {\n          setTimeout(() => setIsPaused(false), 500);\n        }\n      };\n\n      requestAnimationFrame(animateMomentum);\n    } else {\n      setTimeout(() => setIsPaused(false), 500);\n    }\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\n\n  const handleTouchMove = useCallback(\n    (e) => {\n      if (isUserInteracting && scrollContainerRef.current) {\n        const touchX = e.touches[0].clientX;\n        const diff = touchStartX - touchX;\n        const now = performance.now();\n        const deltaTime = now - lastTouchTime;\n        const deltaX = touchX - lastTouchX;\n\n        // Improved velocity calculation\n        const newVelocity = deltaX / Math.max(deltaTime, 1);\n        setTouchVelocity(newVelocity * 1.5); // Increased multiplier for smoother momentum\n\n        setLastTouchX(touchX);\n        setLastTouchTime(now);\n\n        setScrollPosition((prev) => {\n          const sensitivity = isMobile ? 1.5 : 1.2;\n          const newPosition = prev + diff * sensitivity;\n          setTouchStartX(touchX);\n\n          // Enhanced elastic boundaries\n          if (newPosition < 0) {\n            return Math.max(newPosition * 0.3, -containerWidth * 0.1);\n          }\n          if (newPosition > contentWidth - containerWidth) {\n            const overscroll = newPosition - (contentWidth - containerWidth);\n            return contentWidth - containerWidth + overscroll * 0.3;\n          }\n\n          return newPosition;\n        });\n      }\n    },\n    [\n      isUserInteracting,\n      touchStartX,\n      lastTouchTime,\n      lastTouchX,\n      containerWidth,\n      contentWidth,\n      isMobile,\n    ]\n  );\n\n  // Memoized collection items\n  const collectionItems = useMemo(() => {\n    return collectionsData.map((item, index) => {\n      const waveOffset = getWaveOffset(index);\n      const itemSize = getItemSize(index);\n\n      return (\n        <div\n          key={item.id}\n          className={`collection-item ${\n            hoverItemIndex === index ? \"item-hovered\" : \"\"\n          }`}\n          style={{\n            animationDelay: `${index * 0.1}s`,\n            transform: `translateY(${waveOffset}px)`,\n            width: `${itemSize.width}px`,\n            height: `${itemSize.height}px`,\n            transition: \"transform 0.5s ease, scale 0.3s ease\",\n          }}\n          onMouseEnter={() => handleItemHover(index)}\n          onMouseLeave={handleItemLeave}\n        >\n          <Link to=\"/collection\" className=\"collection-link\">\n            <div className=\"collection-image-wrapper\">\n              <OptimizedImage\n                src={getImageUrl(item.image)}\n                alt={item.alt}\n                className=\"collection-image\"\n                priority={index < 5}\n                width={itemSize.width}\n                height={itemSize.height}\n                sizes=\"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\n              />\n              <div className=\"collection-overlay\">\n                <div className=\"collection-info\">\n                  <h3 className=\"collection-title\">{item.title}</h3>\n                  <p className=\"collection-artist\">{item.artist}</p>\n                </div>\n              </div>\n            </div>\n          </Link>\n        </div>\n      );\n    });\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\n\n  return (\n    <section className=\"collections-section\" id=\"collections\">\n      <div className=\"collections-content-container\">\n        <div className=\"collections-header\">\n          <h3 className=\"collections-title\">Bộ sưu tập</h3>\n          {isDesktop && (\n            <p className=\"collections-subtitle\">\n              Khám phá bộ sưu tập nghệ thuật\n            </p>\n          )}\n        </div>\n\n        <div\n          className={`collections-gallery-container ${\n            isVisible ? \"visible\" : \"\"\n          } ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`}\n        >\n          {isDesktop && <div className=\"shadow-effect\"></div>}\n          {isDesktop && <div className=\"left-fade\"></div>}\n\n          {isMobile && showSwipeHint && (\n            <div className=\"swipe-hint\">\n              <span className=\"swipe-text\">\n                Trượt để khám phá\n                <svg\n                  viewBox=\"0 0 24 24\"\n                  fill=\"none\"\n                  height=\"18\"\n                  width=\"18\"\n                  stroke=\"currentColor\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth=\"2\"\n                    d=\"M9 5l7 7-7 7\"\n                  ></path>\n                </svg>\n              </span>\n            </div>\n          )}\n\n          <div\n            className=\"collections-gallery\"\n            ref={scrollContainerRef}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n            onTouchStart={handleTouchStart}\n            onTouchEnd={handleTouchEnd}\n            onTouchMove={handleTouchMove}\n            style={isMobile ? { overflow: \"visible\" } : {}}\n          >\n            <div className=\"collection-inner-container\">{collectionItems}</div>\n          </div>\n        </div>\n\n        <div className=\"collections-footer\">\n          <Link to=\"/collection\" className=\"view-all-links\">\n            Xem tất cả bộ sưu tập\n            <span className=\"arrow-icon\">→</span>\n          </Link>\n        </div>\n      </div>\n    </section>\n  );\n};\n\nexport default React.memo(Collections);\n"
        ],
        "mappings": "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",
        "names": [
          "containerWidth",
          "contentWidth"
        ]
      }
    },
    {
      "name": "vite:worker",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:define",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1751956273950,
      "end": 1751956273950,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1751956273951,
      "end": 1751956273951,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1751956273951,
      "end": 1751956273952,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1751956273952,
      "end": 1751956273952,
      "order": "normal"
    }
  ]
}
