{
  "resolvedId": "C:/Users/.Freelancer/baotangnghethuat/src/components/Home/Collections/Collections.jsx",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import React, {\r\n  useCallback,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { getImageUrl } from \"../../../utils/cloudinary\";\r\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\r\nimport \"./Collections.css\";\r\n\r\n// Collections data - memoized to prevent unnecessary re-creation\r\nconst collectionsData = [\r\n  {\r\n    id: 1,\r\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Cồng Chiên.webp\",\r\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\r\n    description:\r\n      \"Musée Du Pin trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\",\r\n  },\r\n  {\r\n    id: 2,\r\n    title: \"K'ho chăn nuôi\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Lồng Đa Đa.webp\",\r\n    alt: \"K'ho chăn nuôi\",\r\n    description:\r\n      \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Musée Du Pin như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\",\r\n  },\r\n  {\r\n    id: 3,\r\n    title: \"K'ho điêu khắc\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Điêu Khắc.webp\",\r\n    alt: \"K'ho điêu khắc\",\r\n    description:\r\n      \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Musée Du Pin thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa. Tác phẩm mang đậm phong cách mộc mạc nhưng đầy chiều sâu văn hóa, phản ánh vẻ đẹp nội tâm, tinh thần kiên cường và vai trò quan trọng của người phụ nữ trong đời sống cộng đồng K'ho.\",\r\n  },\r\n  {\r\n    id: 4,\r\n    title: \"K'ho lễ hội\",\r\n    artist: \"Trưng bày\",\r\n    image: \"36 (2).webp\",\r\n    alt: \"K'ho lễ hội\",\r\n    description:\r\n      \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\",\r\n  },\r\n  {\r\n    id: 5,\r\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    artist: \"Tham quan\",\r\n    image: \"Nồi Đất.webp\",\r\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    description:\r\n      \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\",\r\n  },\r\n  {\r\n    id: 6,\r\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    artist: \"Tham quan\",\r\n    image: \"Chiếc Gùi.webp\",\r\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    description: \"Chiếc gùi\",\r\n  },\r\n  {\r\n    id: 7,\r\n    title: \"Phức Tầng\",\r\n    artist: \"Tham quan\",\r\n    image: \"Thông 2.webp\",\r\n    alt: \"Phức Tầng\",\r\n    description:\r\n      \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\",\r\n  },\r\n  {\r\n    id: 8,\r\n    title: \"Vật liệu\",\r\n    artist: \"Tham quan\",\r\n    image: \"Hoa Ban Trắng.webp\",\r\n    alt: \"Vật liệu\",\r\n    description: \"Vật liệu\",\r\n  },\r\n  {\r\n    id: 9,\r\n    title: \"Redpine Art Studio\",\r\n    artist: \"Lưu trú\",\r\n    image: \"luutrunghethuat.jpg\",\r\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\r\n    description:\r\n      \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\",\r\n  },\r\n  {\r\n    id: 10,\r\n    title: \"Bề mặt ký ức\",\r\n    artist: \"Tham quan\",\r\n    image: \"Lửa.webp\",\r\n    alt: \"Bề mặt ký ức\",\r\n    description: \"Bề mặt ký ức.\",\r\n  },\r\n];\r\n\r\n// Memoized utility functions\r\nconst getWaveOffset = (index) => {\r\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\r\n  return patterns[index % patterns.length];\r\n};\r\n\r\nconst getItemSize = (index) => {\r\n  const sizes = [\r\n    { width: 280, height: 320 },\r\n    { width: 260, height: 340 },\r\n    { width: 290, height: 300 },\r\n    { width: 270, height: 330 },\r\n    { width: 300, height: 310 },\r\n  ];\r\n  return sizes[index % sizes.length];\r\n};\r\n\r\nconst Collections = () => {\r\n  const scrollContainerRef = useRef(null);\r\n  const animationRef = useRef(null);\r\n  const lastTimestampRef = useRef(null);\r\n  const [isVisible, setIsVisible] = useState(false);\r\n  const [scrollPosition, setScrollPosition] = useState(0);\r\n  const [containerWidth, setContainerWidth] = useState(0);\r\n  const [contentWidth, setContentWidth] = useState(0);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  const [isMobile, setIsMobile] = useState(false);\r\n  const [isDesktop, setIsDesktop] = useState(false);\r\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\r\n  const [touchStartX, setTouchStartX] = useState(0);\r\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\r\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\r\n  const [lastTouchX, setLastTouchX] = useState(0);\r\n  const [lastTouchTime, setLastTouchTime] = useState(0);\r\n  const [touchVelocity, setTouchVelocity] = useState(0);\r\n\r\n  // Optimized device type detection with debounce\r\n  useEffect(() => {\r\n    let timeoutId;\r\n    const handleResize = () => {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => {\r\n        const width = window.innerWidth;\r\n        setIsMobile(width <= 768);\r\n        setIsDesktop(width >= 1200);\r\n      }, 100);\r\n    };\r\n\r\n    handleResize();\r\n    window.addEventListener(\"resize\", handleResize);\r\n\r\n    // Hide swipe hint after 5 seconds on mobile\r\n    if (isMobile) {\r\n      const timer = setTimeout(() => {\r\n        setShowSwipeHint(false);\r\n      }, 5000);\r\n      return () => clearTimeout(timer);\r\n    }\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", handleResize);\r\n      clearTimeout(timeoutId);\r\n    };\r\n  }, [isMobile]);\r\n\r\n  // Optimized intersection observer\r\n  const handleVisibilityChange = useCallback((entries) => {\r\n    const entry = entries[0];\r\n    if (entry.isIntersecting) {\r\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\r\n      if (ratio > 0.2) {\r\n        setIsVisible(true);\r\n      }\r\n    } else if (entry.intersectionRatio === 0) {\r\n      setIsVisible(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const options = {\r\n      threshold: [0.1, 0.2, 0.5, 0.8],\r\n      rootMargin: \"0px 0px 100px 0px\",\r\n    };\r\n\r\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\r\n\r\n    if (scrollContainerRef.current) {\r\n      observer.observe(scrollContainerRef.current);\r\n    }\r\n\r\n    return () => {\r\n      if (scrollContainerRef.current) {\r\n        observer.unobserve(scrollContainerRef.current);\r\n      }\r\n    };\r\n  }, [handleVisibilityChange]);\r\n\r\n  // Calculate widths for scroll animation with ResizeObserver\r\n  useEffect(() => {\r\n    if (!scrollContainerRef.current) return;\r\n\r\n    const calculateWidths = () => {\r\n      if (scrollContainerRef.current) {\r\n        const containerWidth = scrollContainerRef.current.clientWidth;\r\n        const contentWidth = scrollContainerRef.current.scrollWidth;\r\n\r\n        setContainerWidth(containerWidth);\r\n        setContentWidth(contentWidth);\r\n      }\r\n    };\r\n\r\n    if (window.ResizeObserver) {\r\n      const resizeObserver = new ResizeObserver(calculateWidths);\r\n      resizeObserver.observe(scrollContainerRef.current);\r\n\r\n      return () => {\r\n        resizeObserver.disconnect();\r\n      };\r\n    } else {\r\n      calculateWidths();\r\n\r\n      let debounceTimer;\r\n      const handleResize = () => {\r\n        clearTimeout(debounceTimer);\r\n        debounceTimer = setTimeout(calculateWidths, 100);\r\n      };\r\n\r\n      window.addEventListener(\"resize\", handleResize);\r\n\r\n      return () => {\r\n        window.removeEventListener(\"resize\", handleResize);\r\n        clearTimeout(debounceTimer);\r\n      };\r\n    }\r\n  }, []);\r\n\r\n  // Enhanced auto-scroll animation with performance optimization\r\n  useEffect(() => {\r\n    if (!isVisible || isPaused) {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n        animationRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (isDesktop && contentWidth <= containerWidth * 1.5) {\r\n      return;\r\n    }\r\n\r\n    const baseScrollSpeed = isMobile ? 0.5 : isDesktop ? 0.8 : 1.2;\r\n    const maxScroll = contentWidth - containerWidth;\r\n\r\n    const animate = (timestamp) => {\r\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\r\n      const elapsed = timestamp - lastTimestampRef.current;\r\n\r\n      let scrollSpeed = baseScrollSpeed;\r\n\r\n      if (isDesktop) {\r\n        scrollSpeed =\r\n          baseScrollSpeed * (Math.min(contentWidth / 4000, 1.2) + 0.3);\r\n      } else {\r\n        scrollSpeed =\r\n          baseScrollSpeed * (Math.min(contentWidth / 3000, 1.5) + 0.2);\r\n      }\r\n\r\n      setScrollPosition((prevPosition) => {\r\n        const easing = isDesktop\r\n          ? 1 - Math.sin((prevPosition / maxScroll) * Math.PI) * 0.15\r\n          : 1 - Math.sin((prevPosition / maxScroll) * Math.PI) * 0.1;\r\n\r\n        const newPosition =\r\n          prevPosition + scrollSpeed * (elapsed / 16) * easing;\r\n\r\n        if (newPosition >= maxScroll) {\r\n          return isDesktop ? 0.05 : 0.1;\r\n        }\r\n        return newPosition;\r\n      });\r\n\r\n      lastTimestampRef.current = timestamp;\r\n      animationRef.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n        animationRef.current = null;\r\n      }\r\n      lastTimestampRef.current = null;\r\n    };\r\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\r\n\r\n  // Update scroll position with hardware acceleration\r\n  useEffect(() => {\r\n    if (scrollContainerRef.current) {\r\n      if (isMobile) {\r\n        scrollContainerRef.current.style.transform = `translateX(-${scrollPosition}px)`;\r\n      } else {\r\n        scrollContainerRef.current.scrollLeft = scrollPosition;\r\n      }\r\n    }\r\n  }, [scrollPosition, isMobile]);\r\n\r\n  // Memoized event handlers for better performance\r\n  const handleItemHover = useCallback(\r\n    (index) => {\r\n      if (isDesktop) {\r\n        setHoverItemIndex(index);\r\n      }\r\n    },\r\n    [isDesktop]\r\n  );\r\n\r\n  const handleItemLeave = useCallback(() => {\r\n    if (isDesktop) {\r\n      setHoverItemIndex(null);\r\n    }\r\n  }, [isDesktop]);\r\n\r\n  const handleMouseEnter = useCallback(() => setIsPaused(true), []);\r\n  const handleMouseLeave = useCallback(() => setIsPaused(false), []);\r\n\r\n  // Enhanced touch handling with better performance\r\n  const handleTouchStart = useCallback((e) => {\r\n    setIsPaused(true);\r\n    setIsUserInteracting(true);\r\n    setTouchStartX(e.touches[0].clientX);\r\n    setLastTouchX(e.touches[0].clientX);\r\n    setLastTouchTime(Date.now());\r\n    setShowSwipeHint(false);\r\n  }, []);\r\n\r\n  const handleTouchEnd = useCallback(() => {\r\n    setIsUserInteracting(false);\r\n\r\n    if (Math.abs(touchVelocity) > 0.5) {\r\n      const momentum = touchVelocity * 100;\r\n      const targetScroll = scrollPosition + momentum;\r\n\r\n      const startScroll = scrollPosition;\r\n      const startTime = Date.now();\r\n      const duration = 500;\r\n\r\n      const animateMomentum = () => {\r\n        const elapsed = Date.now() - startTime;\r\n        const progress = Math.min(elapsed / duration, 1);\r\n\r\n        const easeOut = (t) => 1 - Math.pow(1 - t, 3);\r\n        const currentProgress = easeOut(progress);\r\n\r\n        const newScroll =\r\n          startScroll + (targetScroll - startScroll) * currentProgress;\r\n\r\n        setScrollPosition(\r\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\r\n        );\r\n\r\n        if (progress < 1) {\r\n          requestAnimationFrame(animateMomentum);\r\n        } else {\r\n          setTimeout(() => {\r\n            setIsPaused(false);\r\n          }, 1000);\r\n        }\r\n      };\r\n\r\n      requestAnimationFrame(animateMomentum);\r\n    } else {\r\n      setTimeout(() => {\r\n        setIsPaused(false);\r\n      }, 1000);\r\n    }\r\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\r\n\r\n  const handleTouchMove = useCallback(\r\n    (e) => {\r\n      if (isUserInteracting && scrollContainerRef.current) {\r\n        const touchX = e.touches[0].clientX;\r\n        const diff = touchStartX - touchX;\r\n\r\n        const now = Date.now();\r\n        const deltaTime = now - lastTouchTime;\r\n        const deltaX = touchX - lastTouchX;\r\n        setTouchVelocity(deltaX / deltaTime);\r\n\r\n        setLastTouchX(touchX);\r\n        setLastTouchTime(now);\r\n\r\n        setScrollPosition((prev) => {\r\n          const sensitivity = 1.2;\r\n          const newPosition = prev + diff * sensitivity;\r\n          setTouchStartX(touchX);\r\n\r\n          if (newPosition < 0) {\r\n            return Math.max(newPosition * 0.5, -containerWidth * 0.1);\r\n          }\r\n          if (newPosition > contentWidth - containerWidth) {\r\n            const overscroll = newPosition - (contentWidth - containerWidth);\r\n            return contentWidth - containerWidth + overscroll * 0.5;\r\n          }\r\n\r\n          return newPosition;\r\n        });\r\n      }\r\n    },\r\n    [\r\n      isUserInteracting,\r\n      touchStartX,\r\n      lastTouchTime,\r\n      lastTouchX,\r\n      containerWidth,\r\n      contentWidth,\r\n    ]\r\n  );\r\n\r\n  // Memoized collection items\r\n  const collectionItems = useMemo(() => {\r\n    return collectionsData.map((item, index) => {\r\n      const waveOffset = getWaveOffset(index);\r\n      const itemSize = getItemSize(index);\r\n\r\n      return (\r\n        <div\r\n          key={item.id}\r\n          className={`collection-item ${\r\n            hoverItemIndex === index ? \"item-hovered\" : \"\"\r\n          }`}\r\n          style={{\r\n            animationDelay: `${index * 0.1}s`,\r\n            transform: `translateY(${waveOffset}px)`,\r\n            width: `${itemSize.width}px`,\r\n            height: `${itemSize.height}px`,\r\n            transition: \"transform 0.5s ease, scale 0.3s ease\",\r\n          }}\r\n          onMouseEnter={() => handleItemHover(index)}\r\n          onMouseLeave={handleItemLeave}\r\n        >\r\n          <Link to=\"/collection\" className=\"collection-link\">\r\n            <div className=\"collection-image-wrapper\">\r\n              <OptimizedImage\r\n                src={getImageUrl(item.image)}\r\n                alt={item.alt}\r\n                className=\"collection-image\"\r\n                priority={index < 5}\r\n                width={itemSize.width}\r\n                height={itemSize.height}\r\n                sizes=\"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\r\n              />\r\n              <div className=\"collection-overlay\">\r\n                <div className=\"collection-info\">\r\n                  <h3 className=\"collection-title\">{item.title}</h3>\r\n                  <p className=\"collection-artist\">{item.artist}</p>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </Link>\r\n        </div>\r\n      );\r\n    });\r\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\r\n\r\n  return (\r\n    <section className=\"collections-section\" id=\"collections\">\r\n      <div className=\"collections-content-container\">\r\n        <div className=\"collections-header\">\r\n          <h2 className=\"collections-title\">Bộ sưu tập</h2>\r\n          {isDesktop && (\r\n            <p className=\"collections-subtitle\">\r\n              Khám phá bộ sưu tập nghệ thuật\r\n            </p>\r\n          )}\r\n        </div>\r\n\r\n        <div\r\n          className={`collections-gallery-container ${\r\n            isVisible ? \"visible\" : \"\"\r\n          } ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`}\r\n        >\r\n          {isDesktop && <div className=\"shadow-effect\"></div>}\r\n          {isDesktop && <div className=\"left-fade\"></div>}\r\n\r\n          {isMobile && showSwipeHint && (\r\n            <div className=\"swipe-hint\">\r\n              <span className=\"swipe-text\">\r\n                Trượt để khám phá\r\n                <svg\r\n                  viewBox=\"0 0 24 24\"\r\n                  fill=\"none\"\r\n                  height=\"18\"\r\n                  width=\"18\"\r\n                  stroke=\"currentColor\"\r\n                >\r\n                  <path\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    strokeWidth=\"2\"\r\n                    d=\"M9 5l7 7-7 7\"\r\n                  ></path>\r\n                </svg>\r\n              </span>\r\n            </div>\r\n          )}\r\n\r\n          <div\r\n            className=\"collections-gallery\"\r\n            ref={scrollContainerRef}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            onTouchStart={handleTouchStart}\r\n            onTouchEnd={handleTouchEnd}\r\n            onTouchMove={handleTouchMove}\r\n            style={isMobile ? { overflow: \"visible\" } : {}}\r\n          >\r\n            <div className=\"collection-inner-container\">{collectionItems}</div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"collections-footer\">\r\n          <Link to=\"/collection\" className=\"view-all-link\">\r\n            Xem tất cả bộ sưu tập\r\n            <span className=\"arrow-icon\">→</span>\r\n          </Link>\r\n        </div>\r\n      </div>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default React.memo(Collections);\r\n",
      "start": 1749089002862,
      "end": 1749089003767,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1749089003767,
      "end": 1749089003767,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "result": "import { jsx, jsxs } from \"react/jsx-runtime\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { getImageUrl } from \"../../../utils/cloudinary\";\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\nimport \"./Collections.css\";\nconst collectionsData = [\n  {\n    id: 1,\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\n    artist: \"Trưng bày\",\n    image: \"Cồng Chiên.webp\",\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\n    description: \"Musée Du Pin trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\"\n  },\n  {\n    id: 2,\n    title: \"K'ho chăn nuôi\",\n    artist: \"Trưng bày\",\n    image: \"Lồng Đa Đa.webp\",\n    alt: \"K'ho chăn nuôi\",\n    description: \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Musée Du Pin như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\"\n  },\n  {\n    id: 3,\n    title: \"K'ho điêu khắc\",\n    artist: \"Trưng bày\",\n    image: \"Điêu Khắc.webp\",\n    alt: \"K'ho điêu khắc\",\n    description: \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Musée Du Pin thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa. Tác phẩm mang đậm phong cách mộc mạc nhưng đầy chiều sâu văn hóa, phản ánh vẻ đẹp nội tâm, tinh thần kiên cường và vai trò quan trọng của người phụ nữ trong đời sống cộng đồng K'ho.\"\n  },\n  {\n    id: 4,\n    title: \"K'ho lễ hội\",\n    artist: \"Trưng bày\",\n    image: \"36 (2).webp\",\n    alt: \"K'ho lễ hội\",\n    description: \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\"\n  },\n  {\n    id: 5,\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\n    artist: \"Tham quan\",\n    image: \"Nồi Đất.webp\",\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\n    description: \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\"\n  },\n  {\n    id: 6,\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\n    artist: \"Tham quan\",\n    image: \"Chiếc Gùi.webp\",\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\n    description: \"Chiếc gùi\"\n  },\n  {\n    id: 7,\n    title: \"Phức Tầng\",\n    artist: \"Tham quan\",\n    image: \"Thông 2.webp\",\n    alt: \"Phức Tầng\",\n    description: \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\"\n  },\n  {\n    id: 8,\n    title: \"Vật liệu\",\n    artist: \"Tham quan\",\n    image: \"Hoa Ban Trắng.webp\",\n    alt: \"Vật liệu\",\n    description: \"Vật liệu\"\n  },\n  {\n    id: 9,\n    title: \"Redpine Art Studio\",\n    artist: \"Lưu trú\",\n    image: \"luutrunghethuat.jpg\",\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\n    description: \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\"\n  },\n  {\n    id: 10,\n    title: \"Bề mặt ký ức\",\n    artist: \"Tham quan\",\n    image: \"Lửa.webp\",\n    alt: \"Bề mặt ký ức\",\n    description: \"Bề mặt ký ức.\"\n  }\n];\nconst getWaveOffset = (index) => {\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\n  return patterns[index % patterns.length];\n};\nconst getItemSize = (index) => {\n  const sizes = [\n    { width: 280, height: 320 },\n    { width: 260, height: 340 },\n    { width: 290, height: 300 },\n    { width: 270, height: 330 },\n    { width: 300, height: 310 }\n  ];\n  return sizes[index % sizes.length];\n};\nconst Collections = () => {\n  const scrollContainerRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastTimestampRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [contentWidth, setContentWidth] = useState(0);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const [isDesktop, setIsDesktop] = useState(false);\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\n  const [touchStartX, setTouchStartX] = useState(0);\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\n  const [lastTouchX, setLastTouchX] = useState(0);\n  const [lastTouchTime, setLastTouchTime] = useState(0);\n  const [touchVelocity, setTouchVelocity] = useState(0);\n  useEffect(() => {\n    let timeoutId;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const width = window.innerWidth;\n        setIsMobile(width <= 768);\n        setIsDesktop(width >= 1200);\n      }, 100);\n    };\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n    if (isMobile) {\n      const timer = setTimeout(() => {\n        setShowSwipeHint(false);\n      }, 5e3);\n      return () => clearTimeout(timer);\n    }\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      clearTimeout(timeoutId);\n    };\n  }, [isMobile]);\n  const handleVisibilityChange = useCallback((entries) => {\n    const entry = entries[0];\n    if (entry.isIntersecting) {\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\n      if (ratio > 0.2) {\n        setIsVisible(true);\n      }\n    } else if (entry.intersectionRatio === 0) {\n      setIsVisible(false);\n    }\n  }, []);\n  useEffect(() => {\n    const options = {\n      threshold: [0.1, 0.2, 0.5, 0.8],\n      rootMargin: \"0px 0px 100px 0px\"\n    };\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\n    if (scrollContainerRef.current) {\n      observer.observe(scrollContainerRef.current);\n    }\n    return () => {\n      if (scrollContainerRef.current) {\n        observer.unobserve(scrollContainerRef.current);\n      }\n    };\n  }, [handleVisibilityChange]);\n  useEffect(() => {\n    if (!scrollContainerRef.current) return;\n    const calculateWidths = () => {\n      if (scrollContainerRef.current) {\n        const containerWidth2 = scrollContainerRef.current.clientWidth;\n        const contentWidth2 = scrollContainerRef.current.scrollWidth;\n        setContainerWidth(containerWidth2);\n        setContentWidth(contentWidth2);\n      }\n    };\n    if (window.ResizeObserver) {\n      const resizeObserver = new ResizeObserver(calculateWidths);\n      resizeObserver.observe(scrollContainerRef.current);\n      return () => {\n        resizeObserver.disconnect();\n      };\n    } else {\n      calculateWidths();\n      let debounceTimer;\n      const handleResize = () => {\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(calculateWidths, 100);\n      };\n      window.addEventListener(\"resize\", handleResize);\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n        clearTimeout(debounceTimer);\n      };\n    }\n  }, []);\n  useEffect(() => {\n    if (!isVisible || isPaused) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      return;\n    }\n    if (isDesktop && contentWidth <= containerWidth * 1.5) {\n      return;\n    }\n    const baseScrollSpeed = isMobile ? 0.5 : isDesktop ? 0.8 : 1.2;\n    const maxScroll = contentWidth - containerWidth;\n    const animate = (timestamp) => {\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\n      const elapsed = timestamp - lastTimestampRef.current;\n      let scrollSpeed = baseScrollSpeed;\n      if (isDesktop) {\n        scrollSpeed = baseScrollSpeed * (Math.min(contentWidth / 4e3, 1.2) + 0.3);\n      } else {\n        scrollSpeed = baseScrollSpeed * (Math.min(contentWidth / 3e3, 1.5) + 0.2);\n      }\n      setScrollPosition((prevPosition) => {\n        const easing = isDesktop ? 1 - Math.sin(prevPosition / maxScroll * Math.PI) * 0.15 : 1 - Math.sin(prevPosition / maxScroll * Math.PI) * 0.1;\n        const newPosition = prevPosition + scrollSpeed * (elapsed / 16) * easing;\n        if (newPosition >= maxScroll) {\n          return isDesktop ? 0.05 : 0.1;\n        }\n        return newPosition;\n      });\n      lastTimestampRef.current = timestamp;\n      animationRef.current = requestAnimationFrame(animate);\n    };\n    animationRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      lastTimestampRef.current = null;\n    };\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      if (isMobile) {\n        scrollContainerRef.current.style.transform = `translateX(-${scrollPosition}px)`;\n      } else {\n        scrollContainerRef.current.scrollLeft = scrollPosition;\n      }\n    }\n  }, [scrollPosition, isMobile]);\n  const handleItemHover = useCallback(\n    (index) => {\n      if (isDesktop) {\n        setHoverItemIndex(index);\n      }\n    },\n    [isDesktop]\n  );\n  const handleItemLeave = useCallback(() => {\n    if (isDesktop) {\n      setHoverItemIndex(null);\n    }\n  }, [isDesktop]);\n  const handleMouseEnter = useCallback(() => setIsPaused(true), []);\n  const handleMouseLeave = useCallback(() => setIsPaused(false), []);\n  const handleTouchStart = useCallback((e) => {\n    setIsPaused(true);\n    setIsUserInteracting(true);\n    setTouchStartX(e.touches[0].clientX);\n    setLastTouchX(e.touches[0].clientX);\n    setLastTouchTime(Date.now());\n    setShowSwipeHint(false);\n  }, []);\n  const handleTouchEnd = useCallback(() => {\n    setIsUserInteracting(false);\n    if (Math.abs(touchVelocity) > 0.5) {\n      const momentum = touchVelocity * 100;\n      const targetScroll = scrollPosition + momentum;\n      const startScroll = scrollPosition;\n      const startTime = Date.now();\n      const duration = 500;\n      const animateMomentum = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n        const easeOut = (t) => 1 - Math.pow(1 - t, 3);\n        const currentProgress = easeOut(progress);\n        const newScroll = startScroll + (targetScroll - startScroll) * currentProgress;\n        setScrollPosition(\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\n        );\n        if (progress < 1) {\n          requestAnimationFrame(animateMomentum);\n        } else {\n          setTimeout(() => {\n            setIsPaused(false);\n          }, 1e3);\n        }\n      };\n      requestAnimationFrame(animateMomentum);\n    } else {\n      setTimeout(() => {\n        setIsPaused(false);\n      }, 1e3);\n    }\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\n  const handleTouchMove = useCallback(\n    (e) => {\n      if (isUserInteracting && scrollContainerRef.current) {\n        const touchX = e.touches[0].clientX;\n        const diff = touchStartX - touchX;\n        const now = Date.now();\n        const deltaTime = now - lastTouchTime;\n        const deltaX = touchX - lastTouchX;\n        setTouchVelocity(deltaX / deltaTime);\n        setLastTouchX(touchX);\n        setLastTouchTime(now);\n        setScrollPosition((prev) => {\n          const sensitivity = 1.2;\n          const newPosition = prev + diff * sensitivity;\n          setTouchStartX(touchX);\n          if (newPosition < 0) {\n            return Math.max(newPosition * 0.5, -containerWidth * 0.1);\n          }\n          if (newPosition > contentWidth - containerWidth) {\n            const overscroll = newPosition - (contentWidth - containerWidth);\n            return contentWidth - containerWidth + overscroll * 0.5;\n          }\n          return newPosition;\n        });\n      }\n    },\n    [\n      isUserInteracting,\n      touchStartX,\n      lastTouchTime,\n      lastTouchX,\n      containerWidth,\n      contentWidth\n    ]\n  );\n  const collectionItems = useMemo(() => {\n    return collectionsData.map((item, index) => {\n      const waveOffset = getWaveOffset(index);\n      const itemSize = getItemSize(index);\n      return /* @__PURE__ */ jsx(\n        \"div\",\n        {\n          className: `collection-item ${hoverItemIndex === index ? \"item-hovered\" : \"\"}`,\n          style: {\n            animationDelay: `${index * 0.1}s`,\n            transform: `translateY(${waveOffset}px)`,\n            width: `${itemSize.width}px`,\n            height: `${itemSize.height}px`,\n            transition: \"transform 0.5s ease, scale 0.3s ease\"\n          },\n          onMouseEnter: () => handleItemHover(index),\n          onMouseLeave: handleItemLeave,\n          children: /* @__PURE__ */ jsx(Link, { to: \"/collection\", className: \"collection-link\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collection-image-wrapper\", children: [\n            /* @__PURE__ */ jsx(\n              OptimizedImage,\n              {\n                src: getImageUrl(item.image),\n                alt: item.alt,\n                className: \"collection-image\",\n                priority: index < 5,\n                width: itemSize.width,\n                height: itemSize.height,\n                sizes: \"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\n              }\n            ),\n            /* @__PURE__ */ jsx(\"div\", { className: \"collection-overlay\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collection-info\", children: [\n              /* @__PURE__ */ jsx(\"h3\", { className: \"collection-title\", children: item.title }),\n              /* @__PURE__ */ jsx(\"p\", { className: \"collection-artist\", children: item.artist })\n            ] }) })\n          ] }) })\n        },\n        item.id\n      );\n    });\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\n  return /* @__PURE__ */ jsx(\"section\", { className: \"collections-section\", id: \"collections\", children: /* @__PURE__ */ jsxs(\"div\", { className: \"collections-content-container\", children: [\n    /* @__PURE__ */ jsxs(\"div\", { className: \"collections-header\", children: [\n      /* @__PURE__ */ jsx(\"h2\", { className: \"collections-title\", children: \"Bộ sưu tập\" }),\n      isDesktop && /* @__PURE__ */ jsx(\"p\", { className: \"collections-subtitle\", children: \"Khám phá bộ sưu tập nghệ thuật\" })\n    ] }),\n    /* @__PURE__ */ jsxs(\n      \"div\",\n      {\n        className: `collections-gallery-container ${isVisible ? \"visible\" : \"\"} ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`,\n        children: [\n          isDesktop && /* @__PURE__ */ jsx(\"div\", { className: \"shadow-effect\" }),\n          isDesktop && /* @__PURE__ */ jsx(\"div\", { className: \"left-fade\" }),\n          isMobile && showSwipeHint && /* @__PURE__ */ jsx(\"div\", { className: \"swipe-hint\", children: /* @__PURE__ */ jsxs(\"span\", { className: \"swipe-text\", children: [\n            \"Trượt để khám phá\",\n            /* @__PURE__ */ jsx(\n              \"svg\",\n              {\n                viewBox: \"0 0 24 24\",\n                fill: \"none\",\n                height: \"18\",\n                width: \"18\",\n                stroke: \"currentColor\",\n                children: /* @__PURE__ */ jsx(\n                  \"path\",\n                  {\n                    strokeLinecap: \"round\",\n                    strokeLinejoin: \"round\",\n                    strokeWidth: \"2\",\n                    d: \"M9 5l7 7-7 7\"\n                  }\n                )\n              }\n            )\n          ] }) }),\n          /* @__PURE__ */ jsx(\n            \"div\",\n            {\n              className: \"collections-gallery\",\n              ref: scrollContainerRef,\n              onMouseEnter: handleMouseEnter,\n              onMouseLeave: handleMouseLeave,\n              onTouchStart: handleTouchStart,\n              onTouchEnd: handleTouchEnd,\n              onTouchMove: handleTouchMove,\n              style: isMobile ? { overflow: \"visible\" } : {},\n              children: /* @__PURE__ */ jsx(\"div\", { className: \"collection-inner-container\", children: collectionItems })\n            }\n          )\n        ]\n      }\n    ),\n    /* @__PURE__ */ jsx(\"div\", { className: \"collections-footer\", children: /* @__PURE__ */ jsxs(Link, { to: \"/collection\", className: \"view-all-link\", children: [\n      \"Xem tất cả bộ sưu tập\",\n      /* @__PURE__ */ jsx(\"span\", { className: \"arrow-icon\", children: \"→\" })\n    ] }) })\n  ] }) });\n};\nexport default React.memo(Collections);\n",
      "start": 1749089003767,
      "end": 1749089004050,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "C:/Users/.Freelancer/baotangnghethuat/src/components/Home/Collections/Collections.jsx"
        ],
        "sourcesContent": [
          "import React, {\r\n  useCallback,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { getImageUrl } from \"../../../utils/cloudinary\";\r\nimport OptimizedImage from \"../../OptimizedImage/OptimizedImage\";\r\nimport \"./Collections.css\";\r\n\r\n// Collections data - memoized to prevent unnecessary re-creation\r\nconst collectionsData = [\r\n  {\r\n    id: 1,\r\n    title: \"Dụng cụ âm nhạc Tây Nguyên\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Cồng Chiên.webp\",\r\n    alt: \"Dụng cụ âm nhạc Tây Nguyên\",\r\n    description:\r\n      \"Musée Du Pin trưng bày các nhạc cụ truyền thống bằng đồng của các dân tộc Tây Nguyên, tiêu biểu là cồng chiêng – biểu tượng văn hóa và tín ngưỡng thiêng liêng. Âm thanh vang vọng của cồng chiêng thể hiện sự kết nối sâu sắc giữa con người và thế giới tâm linh.\",\r\n  },\r\n  {\r\n    id: 2,\r\n    title: \"K'ho chăn nuôi\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Lồng Đa Đa.webp\",\r\n    alt: \"K'ho chăn nuôi\",\r\n    description:\r\n      \"Lồng đa đa của người K'ho hiện đang được trưng bày tại Musée Du Pin như một biểu tượng mộc mạc nhưng đầy tính văn hóa của đời sống dân tộc Tây Nguyên. Được đan thủ công từ tre nứa, chiếc lồng không chỉ phục vụ mục đích chăn nuôi mà còn phản ánh sự khéo léo, tỉ mỉ và mối liên kết bền chặt giữa con người với thiên nhiên núi rừng.\",\r\n  },\r\n  {\r\n    id: 3,\r\n    title: \"K'ho điêu khắc\",\r\n    artist: \"Trưng bày\",\r\n    image: \"Điêu Khắc.webp\",\r\n    alt: \"K'ho điêu khắc\",\r\n    description:\r\n      \"Tác phẩm điêu khắc người dân tộc K'ho đang được trưng bày tại Musée Du Pin thể hiện hình ảnh phụ nữ Tây Nguyên trong dáng đứng trang nghiêm, tay cầm chiếc chiêng nhỏ – biểu tượng của âm nhạc và tín ngưỡng bản địa. Tác phẩm mang đậm phong cách mộc mạc nhưng đầy chiều sâu văn hóa, phản ánh vẻ đẹp nội tâm, tinh thần kiên cường và vai trò quan trọng của người phụ nữ trong đời sống cộng đồng K'ho.\",\r\n  },\r\n  {\r\n    id: 4,\r\n    title: \"K'ho lễ hội\",\r\n    artist: \"Trưng bày\",\r\n    image: \"36 (2).webp\",\r\n    alt: \"K'ho lễ hội\",\r\n    description:\r\n      \"Ché Ghò Sành là một loại ché cổ nổi tiếng của Tây Nguyên, hiện đang được trưng bày tại Musée Du Pin, đây là biểu tượng của sự giàu có, quyền uy và tín ngưỡng tâm linh trong đời sống người bản địa.\",\r\n  },\r\n  {\r\n    id: 5,\r\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    artist: \"Tham quan\",\r\n    image: \"Nồi Đất.webp\",\r\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    description:\r\n      \"Được chế tác thủ công từ đất nung, nồi có hình dáng đơn giản nhưng chắc chắn, thường dùng để nấu ăn trong các dịp lễ hội hoặc sinh hoạt gia đình\",\r\n  },\r\n  {\r\n    id: 6,\r\n    title: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    artist: \"Tham quan\",\r\n    image: \"Chiếc Gùi.webp\",\r\n    alt: \"K'ho săn bắn, hái lượm, trồng trọt, chăn nuôi\",\r\n    description: \"Chiếc gùi\",\r\n  },\r\n  {\r\n    id: 7,\r\n    title: \"Phức Tầng\",\r\n    artist: \"Tham quan\",\r\n    image: \"Thông 2.webp\",\r\n    alt: \"Phức Tầng\",\r\n    description:\r\n      \"Được Musée Du Pin bắt trọn khoảng khắc các hình ảnh thiên nhiên đậm sắc dân tộc K'ho, tạo nên bức tranh đẹp về đất nước Tây Nguyên.\",\r\n  },\r\n  {\r\n    id: 8,\r\n    title: \"Vật liệu\",\r\n    artist: \"Tham quan\",\r\n    image: \"Hoa Ban Trắng.webp\",\r\n    alt: \"Vật liệu\",\r\n    description: \"Vật liệu\",\r\n  },\r\n  {\r\n    id: 9,\r\n    title: \"Redpine Art Studio\",\r\n    artist: \"Lưu trú\",\r\n    image: \"luutrunghethuat.jpg\",\r\n    alt: \"Redpine Art Studio - Lưu trú nghệ thuật giữa rừng thông Đà Lạt\",\r\n    description:\r\n      \"Redpine Art Studio là không gian lưu trú nghệ thuật độc đáo giữa rừng thông, nơi bạn có thể trải nghiệm nghệ thuật và thiên nhiên Đà Lạt.\",\r\n  },\r\n  {\r\n    id: 10,\r\n    title: \"Bề mặt ký ức\",\r\n    artist: \"Tham quan\",\r\n    image: \"Lửa.webp\",\r\n    alt: \"Bề mặt ký ức\",\r\n    description: \"Bề mặt ký ức.\",\r\n  },\r\n];\r\n\r\n// Memoized utility functions\r\nconst getWaveOffset = (index) => {\r\n  const patterns = [-25, 35, -15, 20, -30, 40, -20, 30, -10, 25];\r\n  return patterns[index % patterns.length];\r\n};\r\n\r\nconst getItemSize = (index) => {\r\n  const sizes = [\r\n    { width: 280, height: 320 },\r\n    { width: 260, height: 340 },\r\n    { width: 290, height: 300 },\r\n    { width: 270, height: 330 },\r\n    { width: 300, height: 310 },\r\n  ];\r\n  return sizes[index % sizes.length];\r\n};\r\n\r\nconst Collections = () => {\r\n  const scrollContainerRef = useRef(null);\r\n  const animationRef = useRef(null);\r\n  const lastTimestampRef = useRef(null);\r\n  const [isVisible, setIsVisible] = useState(false);\r\n  const [scrollPosition, setScrollPosition] = useState(0);\r\n  const [containerWidth, setContainerWidth] = useState(0);\r\n  const [contentWidth, setContentWidth] = useState(0);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  const [isMobile, setIsMobile] = useState(false);\r\n  const [isDesktop, setIsDesktop] = useState(false);\r\n  const [hoverItemIndex, setHoverItemIndex] = useState(null);\r\n  const [touchStartX, setTouchStartX] = useState(0);\r\n  const [isUserInteracting, setIsUserInteracting] = useState(false);\r\n  const [showSwipeHint, setShowSwipeHint] = useState(true);\r\n  const [lastTouchX, setLastTouchX] = useState(0);\r\n  const [lastTouchTime, setLastTouchTime] = useState(0);\r\n  const [touchVelocity, setTouchVelocity] = useState(0);\r\n\r\n  // Optimized device type detection with debounce\r\n  useEffect(() => {\r\n    let timeoutId;\r\n    const handleResize = () => {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => {\r\n        const width = window.innerWidth;\r\n        setIsMobile(width <= 768);\r\n        setIsDesktop(width >= 1200);\r\n      }, 100);\r\n    };\r\n\r\n    handleResize();\r\n    window.addEventListener(\"resize\", handleResize);\r\n\r\n    // Hide swipe hint after 5 seconds on mobile\r\n    if (isMobile) {\r\n      const timer = setTimeout(() => {\r\n        setShowSwipeHint(false);\r\n      }, 5000);\r\n      return () => clearTimeout(timer);\r\n    }\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", handleResize);\r\n      clearTimeout(timeoutId);\r\n    };\r\n  }, [isMobile]);\r\n\r\n  // Optimized intersection observer\r\n  const handleVisibilityChange = useCallback((entries) => {\r\n    const entry = entries[0];\r\n    if (entry.isIntersecting) {\r\n      const ratio = Math.min(entry.intersectionRatio * 1.5, 1);\r\n      if (ratio > 0.2) {\r\n        setIsVisible(true);\r\n      }\r\n    } else if (entry.intersectionRatio === 0) {\r\n      setIsVisible(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const options = {\r\n      threshold: [0.1, 0.2, 0.5, 0.8],\r\n      rootMargin: \"0px 0px 100px 0px\",\r\n    };\r\n\r\n    const observer = new IntersectionObserver(handleVisibilityChange, options);\r\n\r\n    if (scrollContainerRef.current) {\r\n      observer.observe(scrollContainerRef.current);\r\n    }\r\n\r\n    return () => {\r\n      if (scrollContainerRef.current) {\r\n        observer.unobserve(scrollContainerRef.current);\r\n      }\r\n    };\r\n  }, [handleVisibilityChange]);\r\n\r\n  // Calculate widths for scroll animation with ResizeObserver\r\n  useEffect(() => {\r\n    if (!scrollContainerRef.current) return;\r\n\r\n    const calculateWidths = () => {\r\n      if (scrollContainerRef.current) {\r\n        const containerWidth = scrollContainerRef.current.clientWidth;\r\n        const contentWidth = scrollContainerRef.current.scrollWidth;\r\n\r\n        setContainerWidth(containerWidth);\r\n        setContentWidth(contentWidth);\r\n      }\r\n    };\r\n\r\n    if (window.ResizeObserver) {\r\n      const resizeObserver = new ResizeObserver(calculateWidths);\r\n      resizeObserver.observe(scrollContainerRef.current);\r\n\r\n      return () => {\r\n        resizeObserver.disconnect();\r\n      };\r\n    } else {\r\n      calculateWidths();\r\n\r\n      let debounceTimer;\r\n      const handleResize = () => {\r\n        clearTimeout(debounceTimer);\r\n        debounceTimer = setTimeout(calculateWidths, 100);\r\n      };\r\n\r\n      window.addEventListener(\"resize\", handleResize);\r\n\r\n      return () => {\r\n        window.removeEventListener(\"resize\", handleResize);\r\n        clearTimeout(debounceTimer);\r\n      };\r\n    }\r\n  }, []);\r\n\r\n  // Enhanced auto-scroll animation with performance optimization\r\n  useEffect(() => {\r\n    if (!isVisible || isPaused) {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n        animationRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (isDesktop && contentWidth <= containerWidth * 1.5) {\r\n      return;\r\n    }\r\n\r\n    const baseScrollSpeed = isMobile ? 0.5 : isDesktop ? 0.8 : 1.2;\r\n    const maxScroll = contentWidth - containerWidth;\r\n\r\n    const animate = (timestamp) => {\r\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp;\r\n      const elapsed = timestamp - lastTimestampRef.current;\r\n\r\n      let scrollSpeed = baseScrollSpeed;\r\n\r\n      if (isDesktop) {\r\n        scrollSpeed =\r\n          baseScrollSpeed * (Math.min(contentWidth / 4000, 1.2) + 0.3);\r\n      } else {\r\n        scrollSpeed =\r\n          baseScrollSpeed * (Math.min(contentWidth / 3000, 1.5) + 0.2);\r\n      }\r\n\r\n      setScrollPosition((prevPosition) => {\r\n        const easing = isDesktop\r\n          ? 1 - Math.sin((prevPosition / maxScroll) * Math.PI) * 0.15\r\n          : 1 - Math.sin((prevPosition / maxScroll) * Math.PI) * 0.1;\r\n\r\n        const newPosition =\r\n          prevPosition + scrollSpeed * (elapsed / 16) * easing;\r\n\r\n        if (newPosition >= maxScroll) {\r\n          return isDesktop ? 0.05 : 0.1;\r\n        }\r\n        return newPosition;\r\n      });\r\n\r\n      lastTimestampRef.current = timestamp;\r\n      animationRef.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n        animationRef.current = null;\r\n      }\r\n      lastTimestampRef.current = null;\r\n    };\r\n  }, [isVisible, containerWidth, contentWidth, isPaused, isMobile, isDesktop]);\r\n\r\n  // Update scroll position with hardware acceleration\r\n  useEffect(() => {\r\n    if (scrollContainerRef.current) {\r\n      if (isMobile) {\r\n        scrollContainerRef.current.style.transform = `translateX(-${scrollPosition}px)`;\r\n      } else {\r\n        scrollContainerRef.current.scrollLeft = scrollPosition;\r\n      }\r\n    }\r\n  }, [scrollPosition, isMobile]);\r\n\r\n  // Memoized event handlers for better performance\r\n  const handleItemHover = useCallback(\r\n    (index) => {\r\n      if (isDesktop) {\r\n        setHoverItemIndex(index);\r\n      }\r\n    },\r\n    [isDesktop]\r\n  );\r\n\r\n  const handleItemLeave = useCallback(() => {\r\n    if (isDesktop) {\r\n      setHoverItemIndex(null);\r\n    }\r\n  }, [isDesktop]);\r\n\r\n  const handleMouseEnter = useCallback(() => setIsPaused(true), []);\r\n  const handleMouseLeave = useCallback(() => setIsPaused(false), []);\r\n\r\n  // Enhanced touch handling with better performance\r\n  const handleTouchStart = useCallback((e) => {\r\n    setIsPaused(true);\r\n    setIsUserInteracting(true);\r\n    setTouchStartX(e.touches[0].clientX);\r\n    setLastTouchX(e.touches[0].clientX);\r\n    setLastTouchTime(Date.now());\r\n    setShowSwipeHint(false);\r\n  }, []);\r\n\r\n  const handleTouchEnd = useCallback(() => {\r\n    setIsUserInteracting(false);\r\n\r\n    if (Math.abs(touchVelocity) > 0.5) {\r\n      const momentum = touchVelocity * 100;\r\n      const targetScroll = scrollPosition + momentum;\r\n\r\n      const startScroll = scrollPosition;\r\n      const startTime = Date.now();\r\n      const duration = 500;\r\n\r\n      const animateMomentum = () => {\r\n        const elapsed = Date.now() - startTime;\r\n        const progress = Math.min(elapsed / duration, 1);\r\n\r\n        const easeOut = (t) => 1 - Math.pow(1 - t, 3);\r\n        const currentProgress = easeOut(progress);\r\n\r\n        const newScroll =\r\n          startScroll + (targetScroll - startScroll) * currentProgress;\r\n\r\n        setScrollPosition(\r\n          Math.max(0, Math.min(newScroll, contentWidth - containerWidth))\r\n        );\r\n\r\n        if (progress < 1) {\r\n          requestAnimationFrame(animateMomentum);\r\n        } else {\r\n          setTimeout(() => {\r\n            setIsPaused(false);\r\n          }, 1000);\r\n        }\r\n      };\r\n\r\n      requestAnimationFrame(animateMomentum);\r\n    } else {\r\n      setTimeout(() => {\r\n        setIsPaused(false);\r\n      }, 1000);\r\n    }\r\n  }, [touchVelocity, scrollPosition, contentWidth, containerWidth]);\r\n\r\n  const handleTouchMove = useCallback(\r\n    (e) => {\r\n      if (isUserInteracting && scrollContainerRef.current) {\r\n        const touchX = e.touches[0].clientX;\r\n        const diff = touchStartX - touchX;\r\n\r\n        const now = Date.now();\r\n        const deltaTime = now - lastTouchTime;\r\n        const deltaX = touchX - lastTouchX;\r\n        setTouchVelocity(deltaX / deltaTime);\r\n\r\n        setLastTouchX(touchX);\r\n        setLastTouchTime(now);\r\n\r\n        setScrollPosition((prev) => {\r\n          const sensitivity = 1.2;\r\n          const newPosition = prev + diff * sensitivity;\r\n          setTouchStartX(touchX);\r\n\r\n          if (newPosition < 0) {\r\n            return Math.max(newPosition * 0.5, -containerWidth * 0.1);\r\n          }\r\n          if (newPosition > contentWidth - containerWidth) {\r\n            const overscroll = newPosition - (contentWidth - containerWidth);\r\n            return contentWidth - containerWidth + overscroll * 0.5;\r\n          }\r\n\r\n          return newPosition;\r\n        });\r\n      }\r\n    },\r\n    [\r\n      isUserInteracting,\r\n      touchStartX,\r\n      lastTouchTime,\r\n      lastTouchX,\r\n      containerWidth,\r\n      contentWidth,\r\n    ]\r\n  );\r\n\r\n  // Memoized collection items\r\n  const collectionItems = useMemo(() => {\r\n    return collectionsData.map((item, index) => {\r\n      const waveOffset = getWaveOffset(index);\r\n      const itemSize = getItemSize(index);\r\n\r\n      return (\r\n        <div\r\n          key={item.id}\r\n          className={`collection-item ${\r\n            hoverItemIndex === index ? \"item-hovered\" : \"\"\r\n          }`}\r\n          style={{\r\n            animationDelay: `${index * 0.1}s`,\r\n            transform: `translateY(${waveOffset}px)`,\r\n            width: `${itemSize.width}px`,\r\n            height: `${itemSize.height}px`,\r\n            transition: \"transform 0.5s ease, scale 0.3s ease\",\r\n          }}\r\n          onMouseEnter={() => handleItemHover(index)}\r\n          onMouseLeave={handleItemLeave}\r\n        >\r\n          <Link to=\"/collection\" className=\"collection-link\">\r\n            <div className=\"collection-image-wrapper\">\r\n              <OptimizedImage\r\n                src={getImageUrl(item.image)}\r\n                alt={item.alt}\r\n                className=\"collection-image\"\r\n                priority={index < 5}\r\n                width={itemSize.width}\r\n                height={itemSize.height}\r\n                sizes=\"(max-width: 768px) 280px, (max-width: 1200px) 320px, 350px\"\r\n              />\r\n              <div className=\"collection-overlay\">\r\n                <div className=\"collection-info\">\r\n                  <h3 className=\"collection-title\">{item.title}</h3>\r\n                  <p className=\"collection-artist\">{item.artist}</p>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </Link>\r\n        </div>\r\n      );\r\n    });\r\n  }, [hoverItemIndex, handleItemHover, handleItemLeave]);\r\n\r\n  return (\r\n    <section className=\"collections-section\" id=\"collections\">\r\n      <div className=\"collections-content-container\">\r\n        <div className=\"collections-header\">\r\n          <h2 className=\"collections-title\">Bộ sưu tập</h2>\r\n          {isDesktop && (\r\n            <p className=\"collections-subtitle\">\r\n              Khám phá bộ sưu tập nghệ thuật\r\n            </p>\r\n          )}\r\n        </div>\r\n\r\n        <div\r\n          className={`collections-gallery-container ${\r\n            isVisible ? \"visible\" : \"\"\r\n          } ${isDesktop ? \"desktop-view\" : \"\"} wavy-gallery`}\r\n        >\r\n          {isDesktop && <div className=\"shadow-effect\"></div>}\r\n          {isDesktop && <div className=\"left-fade\"></div>}\r\n\r\n          {isMobile && showSwipeHint && (\r\n            <div className=\"swipe-hint\">\r\n              <span className=\"swipe-text\">\r\n                Trượt để khám phá\r\n                <svg\r\n                  viewBox=\"0 0 24 24\"\r\n                  fill=\"none\"\r\n                  height=\"18\"\r\n                  width=\"18\"\r\n                  stroke=\"currentColor\"\r\n                >\r\n                  <path\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    strokeWidth=\"2\"\r\n                    d=\"M9 5l7 7-7 7\"\r\n                  ></path>\r\n                </svg>\r\n              </span>\r\n            </div>\r\n          )}\r\n\r\n          <div\r\n            className=\"collections-gallery\"\r\n            ref={scrollContainerRef}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            onTouchStart={handleTouchStart}\r\n            onTouchEnd={handleTouchEnd}\r\n            onTouchMove={handleTouchMove}\r\n            style={isMobile ? { overflow: \"visible\" } : {}}\r\n          >\r\n            <div className=\"collection-inner-container\">{collectionItems}</div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"collections-footer\">\r\n          <Link to=\"/collection\" className=\"view-all-link\">\r\n            Xem tất cả bộ sưu tập\r\n            <span className=\"arrow-icon\">→</span>\r\n          </Link>\r\n        </div>\r\n      </div>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default React.memo(Collections);\r\n"
        ],
        "mappings": "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",
        "names": [
          "containerWidth",
          "contentWidth"
        ]
      }
    },
    {
      "name": "vite:worker",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:define",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1749089004050,
      "end": 1749089004050,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1749089004050,
      "end": 1749089004051,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1749089004051,
      "end": 1749089004051,
      "order": "normal"
    }
  ]
}
