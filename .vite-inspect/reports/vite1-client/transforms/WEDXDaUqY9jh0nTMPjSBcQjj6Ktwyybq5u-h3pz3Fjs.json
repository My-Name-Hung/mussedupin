{
  "resolvedId": "C:/Users/.Freelancer/baotangnghethuat/src/hooks/useImageCache.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { useCallback, useRef } from \"react\";\r\n\r\n// Memory cache for fastest access\r\nconst memoryCache = new Map();\r\n\r\n// IndexedDB setup\r\nconst DB_NAME = \"imageCache\";\r\nconst STORE_NAME = \"images\";\r\nconst DB_VERSION = 1;\r\n\r\nconst openDB = () => {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n    request.onerror = () => reject(request.error);\r\n    request.onsuccess = () => resolve(request.result);\r\n\r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\r\n        db.createObjectStore(STORE_NAME);\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Helper to get sessionStorage key\r\nconst getSessionKey = (src) => `imagecache_${src}`;\r\n\r\nexport default function useImageCache() {\r\n  const loadingRef = useRef(new Set());\r\n\r\n  const preload = useCallback(async (src) => {\r\n    if (!src) return false;\r\n\r\n    // Check memory cache first\r\n    if (memoryCache.has(src)) {\r\n      return true;\r\n    }\r\n\r\n    // Check if already loading\r\n    if (loadingRef.current.has(src)) {\r\n      return new Promise((resolve) => {\r\n        const checkLoaded = () => {\r\n          if (memoryCache.has(src) || !loadingRef.current.has(src)) {\r\n            resolve(true);\r\n          } else {\r\n            setTimeout(checkLoaded, 100);\r\n          }\r\n        };\r\n        checkLoaded();\r\n      });\r\n    }\r\n\r\n    loadingRef.current.add(src);\r\n\r\n    try {\r\n      // Check sessionStorage first\r\n      const sessionKey = getSessionKey(src);\r\n      const sessionData = sessionStorage.getItem(sessionKey);\r\n\r\n      if (sessionData) {\r\n        const blob = new Blob([new Uint8Array(JSON.parse(sessionData))]);\r\n        const url = URL.createObjectURL(blob);\r\n        memoryCache.set(src, url);\r\n        loadingRef.current.delete(src);\r\n        return true;\r\n      }\r\n\r\n      // Check IndexedDB\r\n      try {\r\n        const db = await openDB();\r\n        const transaction = db.transaction([STORE_NAME], \"readonly\");\r\n        const store = transaction.objectStore(STORE_NAME);\r\n        const result = await new Promise((resolve, reject) => {\r\n          const request = store.get(src);\r\n          request.onsuccess = () => resolve(request.result);\r\n          request.onerror = () => reject(request.error);\r\n        });\r\n\r\n        if (result) {\r\n          const url = URL.createObjectURL(result);\r\n          memoryCache.set(src, url);\r\n          loadingRef.current.delete(src);\r\n          return true;\r\n        }\r\n      } catch (dbError) {\r\n        console.warn(\"IndexedDB error:\", dbError);\r\n      }\r\n\r\n      // Fetch and cache\r\n      const response = await fetch(src);\r\n      if (!response.ok) throw new Error(`Failed to load: ${response.status}`);\r\n\r\n      const blob = await response.blob();\r\n      const url = URL.createObjectURL(blob);\r\n\r\n      // Store in memory cache\r\n      memoryCache.set(src, url);\r\n\r\n      // Store in sessionStorage (limit size)\r\n      if (blob.size < 1024 * 1024) {\r\n        // 1MB limit\r\n        try {\r\n          const arrayBuffer = await blob.arrayBuffer();\r\n          const uint8Array = new Uint8Array(arrayBuffer);\r\n          sessionStorage.setItem(\r\n            sessionKey,\r\n            JSON.stringify(Array.from(uint8Array))\r\n          );\r\n        } catch (storageError) {\r\n          console.warn(\"SessionStorage error:\", storageError);\r\n        }\r\n      }\r\n\r\n      // Store in IndexedDB\r\n      try {\r\n        const db = await openDB();\r\n        const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n        const store = transaction.objectStore(STORE_NAME);\r\n        store.put(blob, src);\r\n      } catch (dbError) {\r\n        console.warn(\"IndexedDB store error:\", dbError);\r\n      }\r\n\r\n      loadingRef.current.delete(src);\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"Preload error:\", error);\r\n      loadingRef.current.delete(src);\r\n    return false;\r\n    }\r\n  }, []);\r\n\r\n  // New function to preload multiple assets\r\n  const preloadAll = useCallback(\r\n    async (assetList, concurrency = 6) => {\r\n      if (!assetList || assetList.length === 0) return [];\r\n\r\n      const results = [];\r\n      for (let i = 0; i < assetList.length; i += concurrency) {\r\n        const batch = assetList.slice(i, i + concurrency);\r\n        const batchPromises = batch.map((asset) => preload(asset));\r\n        const batchResults = await Promise.allSettled(batchPromises);\r\n        results.push(...batchResults);\r\n      }\r\n\r\n      return results;\r\n    },\r\n    [preload]\r\n  );\r\n\r\n  const getCachedUrl = useCallback((src) => {\r\n    return memoryCache.get(src) || src;\r\n  }, []);\r\n\r\n  const isLoaded = useCallback((src) => {\r\n    return memoryCache.has(src);\r\n  }, []);\r\n\r\n  const clearCache = useCallback(() => {\r\n    memoryCache.clear();\r\n    loadingRef.current.clear();\r\n\r\n    // Clear sessionStorage\r\n    for (let i = 0; i < sessionStorage.length; i++) {\r\n      const key = sessionStorage.key(i);\r\n      if (key && key.startsWith(\"imagecache_\")) {\r\n        sessionStorage.removeItem(key);\r\n      }\r\n    }\r\n\r\n    // Clear IndexedDB\r\n    openDB()\r\n      .then((db) => {\r\n        const transaction = db.transaction([STORE_NAME], \"readwrite\");\r\n        const store = transaction.objectStore(STORE_NAME);\r\n        store.clear();\r\n      })\r\n      .catch(console.warn);\r\n  }, []);\r\n\r\n  return {\r\n    preload,\r\n    preloadAll,\r\n    getCachedUrl,\r\n    isLoaded,\r\n    clearCache,\r\n  };\r\n}\r\n",
      "start": 1749089002773,
      "end": 1749089003645,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:define",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1749089003645,
      "end": 1749089003645,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1749089003647,
      "end": 1749089003647,
      "order": "normal"
    }
  ]
}
